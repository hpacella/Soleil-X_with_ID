-- The MIT License (MIT)
-- 
-- Copyright (c) 2015 Stanford University.
-- All rights reserved.
-- 
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the "Software"),
-- to deal in the Software without restriction, including without limitation
-- the rights to use, copy, modify, merge, publish, distribute, sublicense,
-- and/or sell copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following conditions:
-- 
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-- DEALINGS IN THE SOFTWARE.

--
-- Module defines all of the AST nodes used
-- to represent the Ebb language.
--
local A = {}
package.loaded["ebb.src.ast"] = A



-----------------
--[[ Symbols ]]--
-----------------

A.Symbol = {}
A.Symbol.__index = A.Symbol
A.GenSymbol = function(name)
  return setmetatable({namestr=name}, A.Symbol)
end
function A.Symbol:UniqueCopy() -- use during sub-tree substitution
  return A.GenSymbol(self.namestr)
end
function A.Symbol:__tostring()
  return self.namestr
end
function A.Symbol:uniquestr()
  setmetatable(self,{})
  local str = self.namestr .. ' ' .. tostring(self)
  setmetatable(self,A.Symbol)
  return str
end
-- for pretty printing...
local function symtostr(sym)
  if getmetatable(sym) == A.Symbol then
    return sym:uniquestr()
  else
    return tostring(sym)
  end
end


---------------------------
--[[ Declare AST types ]]--
---------------------------
local AST             = { kind = 'AST', is_ebb_ast = true }
AST.__index           = AST
A.AST = AST

local all_asts = {}

function A.is_ast(obj)
  local mt = getmetatable(obj)
  return mt and mt.is_ebb_ast
end

function AST:NewKind(kind, child_asts, child_ast_lists)
  local ast = setmetatable({
    kind = kind,
    __child_asts = child_asts or {},
    __child_ast_lists = child_ast_lists or {},
    __blacklist = {}
  }, self)
  ast.__index = ast
  -- blacklist of parameters not to auto-copy on clone
  for _,n in ipairs(ast.__child_asts) do ast.__blacklist[n] = true end
  for _,n in ipairs(ast.__child_ast_lists) do ast.__blacklist[n] = true end

  all_asts[kind] = ast
  A[kind] = ast
  return ast
end

AST:NewKind(         'UserFunction',     {'body','exp'}, {'params'})
AST:NewKind(         'Expression')
AST:NewKind(         'Statement')
  -- Statement*
AST:NewKind(         'Block',            nil, {'statements'})
  -- store condition and block to be executed for if/elseif clauses
AST:NewKind(         'CondBlock',        {'cond','body'})

-- Expressions:
A.Expression:NewKind('BinaryOp',         {'lhs','rhs'})
A.Expression:NewKind('Reduce',           {'exp'})
A.Expression:NewKind('UnaryOp',          {'exp'})

A.Expression:NewKind('TableLookup',      {'table','member'})
A.Expression:NewKind('Call', {'func'},   {'params'})

A.Expression:NewKind('SquareIndex',      {'base','index', 'index2'})

A.Expression:NewKind('Name')
A.Expression:NewKind('Number')
A.Expression:NewKind('String')
A.Expression:NewKind('Bool')
  -- e.g. {0, 4, 3} {true, true, false}
A.Expression:NewKind('VectorLiteral',    nil, {'elems'})
A.Expression:NewKind('MatrixLiteral',    nil, {'elems'})
A.Expression:NewKind('RecordLiteral',    nil, {'names', 'exprs'})

-- non-syntactic expressions (i.e. these will not be generated by the parser)
A.Expression:NewKind('FieldAccess',      {'key'})
A.Expression:NewKind('Global')
A.Expression:NewKind('Cast',             {'value'})
A.Statement :NewKind('FieldWrite',       {'fieldaccess','exp'})
A.Statement :NewKind('GlobalReduce',     {'global','exp'})
-- two special cases for handling reductions correctly
A.Expression:NewKind('FieldAccessIndex', {'key', 'index', 'index2'})
A.Expression:NewKind('GlobalIndex',      {'index', 'index2'})

  -- Quotes mark pre-typechecked sub-trees, and compile to nothing
A.Expression:NewKind('Quote',            {'code'})
A.Expression:NewKind('LetExpr',          {'block', 'exp'})
  -- multi-purpose internal stub for objects captured from the environment
A.Expression:NewKind('LuaObject')
A.Expression:NewKind('Where',            {'field', 'key'})

-- Statements:
  -- if expr then block (elseif cond then block)* (else block)? end
A.Statement :NewKind('IfStatement',      {'else_block'}, {'if_blocks'})
A.Statement :NewKind('WhileStatement',   {'cond','body'})
A.Statement :NewKind('DoStatement',      {'body'})
A.Statement :NewKind('RepeatStatement',  {'body','cond'})
A.Statement :NewKind('ExprStatement',    {'exp'})
A.Statement :NewKind('Assignment',       {'lvalue','exp'})
A.Statement :NewKind('DeclStatement',    {'typeexpression','initializer'})
A.Statement :NewKind('NumericFor',       {'lower','upper','step','body'})
A.Statement :NewKind('GenericFor',       {'set','body'})
A.Statement :NewKind('Break')

A.Statement :NewKind('InsertStatement',  {'record','relation'})
A.Statement :NewKind('DeleteStatement',  {'key'})



-----------------------------
--[[ Lvalue flags        ]]--
-----------------------------
A.FieldAccess.is_lvalue = true
A.Global.is_lvalue      = true
A.Name.is_lvalue        = true


----------------------------------
--[[ Definition of a Literal  ]]--
----------------------------------
function AST:isLiteral() return false end
function A.Number:isLiteral() return true end
function A.String:isLiteral() return true end
function A.Bool:isLiteral() return true end
function A.VectorLiteral:isLiteral()
  for i,e in ipairs(self.elems) do
    if not e:isLiteral() then return false end
  end
  return true
end
function A.MatrixLiteral:isLiteral()
  for i,e in ipairs(self.elems) do
    if not e:isLiteral() then return false end
  end
  return true
end

-----------------------------
--[[ General AST Methods ]]--
-----------------------------
function AST:New (P)
  local newnode = 
  { 
    kind       = self.kind, -- Is this even necessary?
    linenumber = P:cur().linenumber,
    filename   = P.source,
    offset     = P:cur().offset,
  }
  return setmetatable(newnode, self)
end

function AST:copy_location (node)
  self.linenumber = node.linenumber
  self.filename   = node.filename
  self.offset     = node.offset
end

function AST:DeriveFrom (ast)
  local newnode = setmetatable({kind=self.kind}, self)
  newnode:copy_location(ast)
  newnode.name      = ast.name
  return newnode
end

function AST:clone ()
  local copy = setmetatable({}, getmetatable(self))
  for k,v in pairs(self) do
    if not self.__blacklist[k] then copy[k] = v end
  end
  return copy
end

function AST:astSize()
  local size = 1

  for _,n in ipairs(self.__child_asts) do
    local child = self[n]
    if A.is_ast(child) then size = size + child:astSize() end
  end
  for _,n in ipairs(self.__child_ast_lists) do
    local child_list = self[n]
    for _,child in ipairs(child_list) do
      if A.is_ast(child) then size = size + child:astSize() end
    end
  end

  return size
end

-- GENREAL STRUCTURAL RECURSION
function A.NewCopyPass(passname)
  -- install default behaviors on each AST
  local metastr = ""
  for kind, ast in pairs(all_asts) do

    -- function signature
    metastr = metastr..
      "function A."..kind..":"..passname.."(ctxt)\n"..
      "  local copy = self:clone()\n\n"

    -- simple children recursion
    for _,n in ipairs(ast.__child_asts) do
      local selfn = 'self.'..n
      local copyn = 'copy.'..n
      metastr = metastr..
      "  if "..selfn.." then\n"..
      "    if not A.is_ast("..selfn..") then\n"..
      "      "..copyn.." = "..selfn.."\n"..
      "    else\n"..
      "      "..copyn.." = "..selfn..":"..passname.."(ctxt)\n"..
      "    end\n"..
      "  end\n\n"
    end

    -- list children recursion
    for _,n in ipairs(ast.__child_ast_lists) do
      local selfn = 'self.'..n
      local copyn = 'copy.'..n
      metastr = metastr..
      "  if "..selfn.." then\n"..
      "    "..copyn.." = {}\n"..
      "    for i, node in ipairs("..selfn..") do\n"..
      "      if not A.is_ast(node) then\n"..
      "        "..copyn.."[i] = node\n"..
      "      else\n"..
      "        "..copyn.."[i] = node:"..passname.."(ctxt)\n"..
      "      end\n"..
      "    end\n"..
      "  end\n\n"
    end

    -- end function
    metastr = metastr..
      "  return copy\n"..
      "end\n"

  end

  local setup_func = assert(loadstring(metastr))
  setfenv(setup_func, { A = A, ipairs = ipairs })
  setup_func()
end

function A.NewInertPass(passname)
  -- install default behaviors on each AST
  local metastr = ""
  for kind, ast in pairs(all_asts) do

    -- function signature
    metastr = metastr..
      "function A."..kind..":"..passname.."(ctxt)\n\n"

    -- simple children recursion
    for _,n in ipairs(ast.__child_asts) do
      local selfn = 'self.'..n
      metastr = metastr..
      "  if A.is_ast("..selfn..") then\n"..
      "    "..selfn..":"..passname.."(ctxt)\n"..
      "  end\n\n"
    end

    -- list children recursion
    for _,n in ipairs(ast.__child_ast_lists) do
      local selfn = 'self.'..n
      metastr = metastr..
      "  if "..selfn.." then\n"..
      "    for i, node in ipairs("..selfn..") do\n"..
      "      if A.is_ast(node) then\n"..
      "        node:"..passname.."(ctxt)\n"..
      "      end\n"..
      "    end\n"..
      "  end\n\n"
    end

    -- end function
    metastr = metastr..
      "end\n"

  end

  local setup_func = assert(loadstring(metastr))
  setfenv(setup_func, { A = A, ipairs = ipairs })
  setup_func()
end

function AST:is (obj)
  return obj == getmetatable(self)
end


---------------------------
--[[ AST tree printing ]]--
---------------------------
local indent_delta = '   '

local function maybe_type(node)
  if node.node_type then return ' :: '..tostring(node.node_type)
                    else return '' end
end

function AST:pretty_print(indent)
  error('PRETTY PRINT not implemented for AST node ' .. self.kind)
end

function A.UserFunction:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (params, body, exp)")
  indent = indent .. indent_delta
  for i = 1, #self.params do
    print(indent .. tostring(self.params[i]))
  end
  self.body:pretty_print(indent)
  if not self.exp then
    print(indent..indent_delta..'nil')
  else
    self.exp:pretty_print(indent)
  end
end

function A.Block:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
  for i = 1, #self.statements do
    self.statements[i]:pretty_print(indent .. indent_delta)
  end
end

function A.CondBlock:pretty_print (indent)
  print(indent .. self.kind .. ": (cond, block)")
  self.cond:pretty_print(indent .. indent_delta)
  self.body:pretty_print(indent .. indent_delta)
end

function A.BinaryOp:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.op..maybe_type(self))
  self.lhs:pretty_print(indent .. indent_delta)
  self.rhs:pretty_print(indent .. indent_delta)
end

function A.UnaryOp:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.op ..maybe_type(self))
  self.exp:pretty_print(indent .. indent_delta)
end

function A.Reduce:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.op ..maybe_type(self))
  self.exp:pretty_print(indent .. indent_delta)
end

function A.Global:pretty_print(indent)
  indent = indent or ''
  local name = self.name or ""
  print(indent .. self.kind .. ": " .. symtostr(name) ..maybe_type(self))
end

function A.GlobalIndex:pretty_print(indent)
  indent = indent or ''
  local name = self.name or ""
  print(indent .. self.kind .. ": " .. symtostr(name) ..maybe_type(self))
  self.index:pretty_print(indent .. indent_delta)
  if self.index2 then
      self.index2:pretty_print(indent .. indent_delta)
  end
end

function A.Cast:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. tostring(self.node_type))
  self.value:pretty_print(indent .. indent_delta)
end

function A.Quote:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ":" ..maybe_type(self))
  self.code:pretty_print(indent .. indent_delta)
end

function A.LetExpr:pretty_print(indent)
  indent = indent or ''
  local str = indent .. self.kind .. ": ("
  if self.block then str = str .. "block, " end
  if self.exp then str = str .. "exp" end
  print(str .. ")" ..maybe_type(self))
  indent = indent .. indent_delta
  if self.block then
    self.block:pretty_print(indent)
  end
  if self.exp then
    self.exp:pretty_print(indent)
  end
end

function A.FieldAccess:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ': ' .. tostring(self.field)..maybe_type(self))
  self.key:pretty_print(indent..indent_delta)
  print(indent..indent_delta..symtostr(self.name))
end

function A.FieldAccessIndex:pretty_print(indent)
  indent = indent or ''
  print(indent .. self.kind .. ': ' .. tostring(self.field)..maybe_type(self))
  self.key:pretty_print(indent..indent_delta)
  print(indent..indent_delta..symtostr(self.name))
  self.index:pretty_print(indent .. indent_delta)
  if self.index2 then
      self.index2:pretty_print(indent .. indent_delta)
  end
end

function A.Call:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (func, params)"..maybe_type(self))
  if not A.is_ast(self.func) then
    print(indent .. indent_delta .. tostring(self.func))
  else
    self.func:pretty_print(indent .. indent_delta)
  end
  for i = 1, #self.params do
    self.params[i]:pretty_print(indent .. indent_delta)
  end
end

function A.LuaObject:pretty_print (indent)
  indent = indent or ''
  local val = self.node_type and self.node_type.value
  print(indent .. self.kind .. ": " .. tostring(val))
end

function A.TableLookup:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (table, member)"..maybe_type(self))
  self.table:pretty_print(indent .. indent_delta)
  if A.is_ast(self.member) then
    self.member:pretty_print(indent .. indent_delta)
  else
    print(indent .. indent_delta .. tostring(self.member))
  end
end

function A.SquareIndex:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (base, index)"..maybe_type(self))
  self.base:pretty_print(indent .. indent_delta)
  self.index:pretty_print(indent .. indent_delta)
  if self.index2 then
      self.index2:pretty_print(indent .. indent_delta)
  end
end

function A.Name:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. symtostr(self.name)..maybe_type(self))
end

function A.Number:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": " .. self.value ..maybe_type(self))
end

function A.Bool:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ':' .. tostring(self.value))
end

function A.String:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": \"" .. self.value .. "\"")
end

function A.IfStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
  for i = 1, #self.if_blocks do
    self.if_blocks[i]:pretty_print(indent .. indent_delta)
  end
  if self.else_block then
    self.else_block:pretty_print(indent .. indent_delta)
  end
end

function A.WhileStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (condition, body)")
  self.cond:pretty_print(indent .. indent_delta)
  self.body:pretty_print(indent .. indent_delta)
end

function A.DoStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
  self.body:pretty_print(indent .. indent_delta)
end

function A.RepeatStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (body, condition)")
  self.body:pretty_print(indent .. indent_delta)
  self.cond:pretty_print(indent .. indent_delta)
end

function A.DeclStatement:pretty_print (indent)
  indent = indent or ''
  local typexpstr = ''
  if self.typeexpression then typexpstr = "typeexpression," end
  print(indent .. self.kind.. ":(name,"..typexpstr.."initializer)")
  print(indent .. indent_delta .. symtostr(self.name))
  if self.typeexpression then
      print(indent .. indent_delta ..self.typeexpression)
  end
  if self.initializer then
      self.initializer:pretty_print(indent .. indent_delta)
  end
end

function A.ExprStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind ..maybe_type(self))
  self.exp:pretty_print(indent .. indent_delta)
end

function A.Assignment:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ': (lvalue, exp)')
  self.lvalue:pretty_print(indent .. indent_delta)
  self.exp:pretty_print(indent .. indent_delta)
end

function A.GlobalReduce:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": <reduction \'" .. self.reduceop .. '\'>')
  self.global:pretty_print(indent .. indent_delta)
  self.exp:pretty_print(indent .. indent_delta)
end

function A.FieldWrite:pretty_print (indent)
  indent = indent or ''
  if self.reduceop then
    print(indent .. self.kind .. ": <reduction \'" .. self.reduceop .. '\'>')
  else
    print(indent .. self.kind .. ": <write>")
  end
  self.fieldaccess:pretty_print(indent .. indent_delta)
  self.exp:pretty_print(indent .. indent_delta)
end

function A.Break:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind)
end

function A.InsertStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (record,relation)")
  self.record:pretty_print(indent .. indent_delta)
  self.relation:pretty_print(indent .. indent_delta)
end

function A.DeleteStatement:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (key)")
  self.key:pretty_print(indent .. indent_delta)
end

function A.NumericFor:pretty_print (indent) 
  indent = indent or ''
  if self.step then
    print(indent .. self.kind .. ": (name, lower, upper, step, body)")
  else
    print(indent .. self.kind .. ": (name, lower, upper, body)")
  end
  print(indent .. indent_delta .. symtostr(self.name))
  self.lower:pretty_print(indent .. indent_delta)
  self.upper:pretty_print(indent .. indent_delta)
  if self.step then self.step:pretty_print(indent .. indent_delta) end
  self.body:pretty_print(indent .. indent_delta)
end

function A.GenericFor:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (name, set, body)")
  print(indent .. indent_delta .. symtostr(self.name))
  self.set:pretty_print(indent  .. indent_delta)
  self.body:pretty_print(indent .. indent_delta)
end

function A.VectorLiteral:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ":" ..maybe_type(self))
  for i = 1, #self.elems do
    self.elems[i]:pretty_print(indent .. indent_delta)
  end
end
function A.MatrixLiteral:pretty_print (indent)
  indent = indent or ''
  local N = self.n
  local M = self.m
  print(indent .. self.kind .. ": (n,m,elems)"..maybe_type(self))
  print(indent .. indent_delta .. 'n ' .. tostring(N))
  print(indent .. indent_delta .. 'm ' .. tostring(M))
  for i=1,#self.elems do
    self.elems[i]:pretty_print(indent .. indent_delta)
  end
end
function A.RecordLiteral:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (names,exprs)"..maybe_type(self))
  for i,name in ipairs(self.names) do
    print(indent .. indent_delta .. symtostr(name))
    self.exprs[i]:pretty_print(indent .. indent_delta)
  end
end
function A.Where:pretty_print (indent)
  indent = indent or ''
  print(indent .. self.kind .. ": (field, key)" ..maybe_type(self))
  self.field:pretty_print(indent .. indent_delta)
  self.key:pretty_print(indent .. indent_delta)
end

