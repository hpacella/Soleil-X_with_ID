  terra concretize(str : &int8) : int8[256]
      var res : int8[256]
      strncpy(&[&int8](res)[0], str, [uint64](256))
      [&int8](res)[255] = [int8](0)
      return res
  end
local HDF = require "hdf_helper"
local SCHEMA = (require "config_helper").processSchema("config_schema.h")
local Config = SCHEMA.Config
struct particles_columns {
  cell : int3d;
  position : double[3];
  velocity : double[3];
  temperature : double;
  diameter : double;
  density : double;
  deltaVelocityOverRelaxationTime : double[3];
  deltaTemperatureTerm : double;
  position_old : double[3];
  velocity_old : double[3];
  temperature_old : double;
  position_new : double[3];
  velocity_new : double[3];
  temperature_new : double;
  position_ghost : double[3];
  velocity_ghost : double[3];
  velocity_t_ghost : double[3];
  position_t : double[3];
  velocity_t : double[3];
  temperature_t : double;
  __valid : bool;
}
struct Fluid_columns {
  rho : double;
  pressure : double;
  velocity : double[3];
  centerCoordinates : double[3];
  velocityGradientX : double[3];
  velocityGradientY : double[3];
  velocityGradientZ : double[3];
  temperature : double;
  rhoEnthalpy : double;
  kineticEnergy : double;
  sgsEnergy : double;
  sgsEddyViscosity : double;
  sgsEddyKappa : double;
  convectiveSpectralRadius : double;
  viscousSpectralRadius : double;
  heatConductionSpectralRadius : double;
  rhoVelocity : double[3];
  rhoEnergy : double;
  rhoBoundary : double;
  rhoVelocityBoundary : double[3];
  rhoEnergyBoundary : double;
  velocityBoundary : double[3];
  pressureBoundary : double;
  temperatureBoundary : double;
  velocityGradientXBoundary : double[3];
  velocityGradientYBoundary : double[3];
  velocityGradientZBoundary : double[3];
  rho_old : double;
  rhoVelocity_old : double[3];
  rhoEnergy_old : double;
  rho_new : double;
  rhoVelocity_new : double[3];
  rhoEnergy_new : double;
  rho_t : double;
  rhoVelocity_t : double[3];
  rhoEnergy_t : double;
  rhoFluxX : double;
  rhoVelocityFluxX : double[3];
  rhoEnergyFluxX : double;
  rhoFluxY : double;
  rhoVelocityFluxY : double[3];
  rhoEnergyFluxY : double;
  rhoFluxZ : double;
  rhoVelocityFluxZ : double[3];
  rhoEnergyFluxZ : double;
  PD : double;
  dissipation : double;
  dissipationFlux : double;
  to_Radiation : int3d;
}
__demand(__parallel)
task InitParticlesUniform($particles : region(ispace(int1d), particles_columns), $cells : region(ispace(int3d), Fluid_columns), $config : Config, $xBnum : int32, $yBnum : int32, $zBnum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles), writes($particles), reads($cells.velocity), reads($cells.centerCoordinates)
do
  var $pBase : int32 = 0
  for $p : int1d(particles_columns, $particles) in $particles do
    $pBase = int32($p)
    break
  end
  var $lo : int3d = $cells.bounds.lo
  $lo.x = max($lo.x, $xBnum)
  $lo.y = max($lo.y, $yBnum)
  $lo.z = max($lo.z, $zBnum)
  var $hi : int3d = $cells.bounds.hi
  $hi.x = min($hi.x, (($config.Grid.xNum+$xBnum)-1))
  $hi.y = min($hi.y, (($config.Grid.yNum+$yBnum)-1))
  $hi.z = min($hi.z, (($config.Grid.zNum+$zBnum)-1))
  var $xSize : int64 = (($hi.x-$lo.x)+1)
  var $ySize : int64 = (($hi.y-$lo.y)+1)
  var $particlesPerTask : int32 = ($config.Particles.initNum/(($config.Grid.xTiles*$config.Grid.yTiles)*$config.Grid.zTiles))
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if ((int32($p)-$pBase)<$particlesPerTask) then
      (@$p).__valid = true
      var $relIdx : int32 = (int32($p)-$pBase)
      var $c : int3d = int3d({($lo.x+($relIdx%$xSize)), ($lo.y+(($relIdx/$xSize)%$ySize)), ($lo.z+(($relIdx/$xSize)/$ySize))})
      (@$p).cell = $c
      (@$p).position = $cells[(@$p).cell].centerCoordinates
      (@$p).velocity = $cells[(@$p).cell].velocity
      (@$p).density = $config.Particles.density
      (@$p).temperature = $config.Particles.initTemperature
      (@$p).diameter = $config.Particles.diameterMean
    else
    end
  end
end

__demand(__parallel, __cuda)
task AddRadiation($particles : region(ispace(int1d), particles_columns), $config : Config)
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.density), reads($particles.diameter), reads($particles.temperature_t), writes($particles.temperature_t)
do
  var $absorptivity : double = $config.Particles.absorptivity
  var $intensity : double = $config.Radiation.intensity
  var $heatCapacity : double = $config.Particles.heatCapacity
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    var $crossSectionArea : double = (((2*acos(0))*pow((@$p).diameter, 2))/4)
    var $volume : double = (((2*acos(0))*pow((@$p).diameter, 3))/6)
    var $mass : double = ($volume*(@$p).density)
    var $absorbedRadiationIntensity : double = (($absorptivity*$intensity)*$crossSectionArea)
    (@$p).temperature_t += ($absorbedRadiationIntensity/($mass*$heatCapacity))
  end
end

struct Radiation_columns {
  I_1 : double[14];
  I_2 : double[14];
  I_3 : double[14];
  I_4 : double[14];
  I_5 : double[14];
  I_6 : double[14];
  I_7 : double[14];
  I_8 : double[14];
  Iiter_1 : double[14];
  Iiter_2 : double[14];
  Iiter_3 : double[14];
  Iiter_4 : double[14];
  Iiter_5 : double[14];
  Iiter_6 : double[14];
  Iiter_7 : double[14];
  Iiter_8 : double[14];
  G : double;
  S : double;
  Ib : double;
  sigma : double;
  acc_d2 : double;
  acc_d2t4 : double;
}
         terra open_quad_file() : &_IO_FILE
             var f : &_IO_FILE = fopen("LMquads/14.txt", "rb")
             if f == [&_IO_FILE](nil) then
                 printf("Error opening angle file\n")
                 exit(1)
             end
             return f
         end
         terra read_double(f : &_IO_FILE) : double
             var val : double
             if fscanf(f, "%lf\n", &val) < 1 then
                 printf("Error while reading angle file\n")
                 exit(1)
             end
             return val
         end
struct angle {
  xi : double;
  eta : double;
  mu : double;
  w : double;
}
struct face {
  I : double[14];
}
task initialize_faces($faces : region(ispace(int3d), face))
-- leaf (false), inner (false), idempotent (false)
where
  reads($faces.I), writes($faces.I)
do
  for $f : int3d(face, $faces) in $faces do
    for $m : int32 = 0, 14 do
      (@$f).I[$m] = 0
    end
  end
end

task initialize_angles($angles : region(ispace(int1d), angle))
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($angles.w), writes($angles.xi), writes($angles.eta), writes($angles.mu), writes($angles.w)
do
  var $f : &_IO_FILE = open_quad_file()
  read_double($f)
  for $a : int1d(angle, $angles) in $angles do
    (@$a).xi = read_double($f)
  end
  for $a : int1d(angle, $angles) in $angles do
    (@$a).eta = read_double($f)
  end
  for $a : int1d(angle, $angles) in $angles do
    (@$a).mu = read_double($f)
  end
  for $a : int1d(angle, $angles) in $angles do
    (@$a).w = read_double($f)
  end
  fclose($f)
end

task make_interior_partition_x_hi($faces : region(ispace(int3d), face), $x_tiles : ispace(int3d), $Nx : int32, $Ny : int32, $Nz : int32, $ntx : int32, $nty : int32, $ntz : int32) : partition(disjoint, $faces, $x_tiles)
-- leaf (false), inner (false), idempotent (false)
  var $coloring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $tile : int3d($x_tiles) in $x_tiles do
    var $val : int32 = (-1)
    if ($tile.x==($x_tiles.bounds.hi.x-1)) then
      $val = 0
    else
    end
    var $lo : int3d = int3d({x = (($tile.x*$Nx)/$ntx), y = (($tile.y*$Ny)/$nty), z = (($tile.z*$Nz)/$ntz)})
    var $hi : int3d = int3d({x = (((($tile.x+1)*$Nx)/$ntx)+$val), y = (((($tile.y+1)*$Ny)/$nty)-1), z = (((($tile.z+1)*$Nz)/$ntz)-1)})
    if ($hi.x>=($Nx+1)) then
      $lo.x = int64(1)
      $hi.x = int64(0)
    else
    end
    var $rect : rect3d = rect3d({lo = $lo, hi = $hi})
    legion_domain_point_coloring_color_domain($coloring, legion_domain_point_t($tile), legion_domain_t($rect))
  end
  var $p : partition(disjoint, $faces, $x_tiles) = partition(disjoint, $faces, $coloring, $x_tiles)
  legion_domain_point_coloring_destroy($coloring)
  return $p
end

task make_interior_partition_x_lo($faces : region(ispace(int3d), face), $x_tiles : ispace(int3d), $Nx : int32, $Ny : int32, $Nz : int32, $ntx : int32, $nty : int32, $ntz : int32) : partition(disjoint, $faces, $x_tiles)
-- leaf (false), inner (false), idempotent (false)
  var $coloring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $tile : int3d($x_tiles) in $x_tiles do
    var $val : int32 = 1
    if ($tile.x==1) then
      $val = 0
    else
    end
    var $lo : int3d = int3d({x = (((($tile.x-1)*$Nx)/$ntx)+$val), y = (($tile.y*$Ny)/$nty), z = (($tile.z*$Nz)/$ntz)})
    var $hi : int3d = int3d({x = (($tile.x*$Nx)/$ntx), y = (((($tile.y+1)*$Ny)/$nty)-1), z = (((($tile.z+1)*$Nz)/$ntz)-1)})
    if ($lo.x<0) then
      $lo.x = int64(1)
      $hi.x = int64(0)
    else
    end
    var $rect : rect3d = rect3d({lo = $lo, hi = $hi})
    legion_domain_point_coloring_color_domain($coloring, legion_domain_point_t($tile), legion_domain_t($rect))
  end
  var $p : partition(disjoint, $faces, $x_tiles) = partition(disjoint, $faces, $coloring, $x_tiles)
  legion_domain_point_coloring_destroy($coloring)
  return $p
end

task make_interior_partition_y_hi($faces : region(ispace(int3d), face), $y_tiles : ispace(int3d), $Nx : int32, $Ny : int32, $Nz : int32, $ntx : int32, $nty : int32, $ntz : int32) : partition(disjoint, $faces, $y_tiles)
-- leaf (false), inner (false), idempotent (false)
  var $coloring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $tile : int3d($y_tiles) in $y_tiles do
    var $val : int32 = (-1)
    if ($tile.y==($y_tiles.bounds.hi.y-1)) then
      $val = 0
    else
    end
    var $lo : int3d = int3d({x = (($tile.x*$Nx)/$ntx), y = (($tile.y*$Ny)/$nty), z = (($tile.z*$Nz)/$ntz)})
    var $hi : int3d = int3d({x = (((($tile.x+1)*$Nx)/$ntx)-1), y = (((($tile.y+1)*$Ny)/$nty)+$val), z = (((($tile.z+1)*$Nz)/$ntz)-1)})
    if ($hi.y>=($Ny+1)) then
      $lo.y = int64(1)
      $hi.y = int64(0)
    else
    end
    var $rect : rect3d = rect3d({lo = $lo, hi = $hi})
    legion_domain_point_coloring_color_domain($coloring, legion_domain_point_t($tile), legion_domain_t($rect))
  end
  var $p : partition(disjoint, $faces, $y_tiles) = partition(disjoint, $faces, $coloring, $y_tiles)
  legion_domain_point_coloring_destroy($coloring)
  return $p
end

task make_interior_partition_y_lo($faces : region(ispace(int3d), face), $y_tiles : ispace(int3d), $Nx : int32, $Ny : int32, $Nz : int32, $ntx : int32, $nty : int32, $ntz : int32) : partition(disjoint, $faces, $y_tiles)
-- leaf (false), inner (false), idempotent (false)
  var $coloring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $tile : int3d($y_tiles) in $y_tiles do
    var $val : int32 = 1
    if ($tile.y==1) then
      $val = 0
    else
    end
    var $lo : int3d = int3d({x = (($tile.x*$Nx)/$ntx), y = (((($tile.y-1)*$Ny)/$nty)+$val), z = (($tile.z*$Nz)/$ntz)})
    var $hi : int3d = int3d({x = (((($tile.x+1)*$Nx)/$ntx)-1), y = (($tile.y*$Ny)/$nty), z = (((($tile.z+1)*$Nz)/$ntz)-1)})
    if ($lo.y<0) then
      $lo.y = int64(1)
      $hi.y = int64(0)
    else
    end
    var $rect : rect3d = rect3d({lo = $lo, hi = $hi})
    legion_domain_point_coloring_color_domain($coloring, legion_domain_point_t($tile), legion_domain_t($rect))
  end
  var $p : partition(disjoint, $faces, $y_tiles) = partition(disjoint, $faces, $coloring, $y_tiles)
  legion_domain_point_coloring_destroy($coloring)
  return $p
end

task make_interior_partition_z_hi($faces : region(ispace(int3d), face), $z_tiles : ispace(int3d), $Nx : int32, $Ny : int32, $Nz : int32, $ntx : int32, $nty : int32, $ntz : int32) : partition(disjoint, $faces, $z_tiles)
-- leaf (false), inner (false), idempotent (false)
  var $coloring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $tile : int3d($z_tiles) in $z_tiles do
    var $val : int32 = (-1)
    if ($tile.z==($z_tiles.bounds.hi.z-1)) then
      $val = 0
    else
    end
    var $lo : int3d = int3d({x = (($tile.x*$Nx)/$ntx), y = (($tile.y*$Ny)/$nty), z = (($tile.z*$Nz)/$ntz)})
    var $hi : int3d = int3d({x = (((($tile.x+1)*$Nx)/$ntx)-1), y = (((($tile.y+1)*$Ny)/$nty)-1), z = (((($tile.z+1)*$Nz)/$ntz)+$val)})
    if ($hi.z>=($Nz+1)) then
      $lo.z = int64(1)
      $hi.z = int64(0)
    else
    end
    var $rect : rect3d = rect3d({lo = $lo, hi = $hi})
    legion_domain_point_coloring_color_domain($coloring, legion_domain_point_t($tile), legion_domain_t($rect))
  end
  var $p : partition(disjoint, $faces, $z_tiles) = partition(disjoint, $faces, $coloring, $z_tiles)
  legion_domain_point_coloring_destroy($coloring)
  return $p
end

task make_interior_partition_z_lo($faces : region(ispace(int3d), face), $z_tiles : ispace(int3d), $Nx : int32, $Ny : int32, $Nz : int32, $ntx : int32, $nty : int32, $ntz : int32) : partition(disjoint, $faces, $z_tiles)
-- leaf (false), inner (false), idempotent (false)
  var $coloring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $tile : int3d($z_tiles) in $z_tiles do
    var $val : int32 = 1
    if ($tile.z==1) then
      $val = 0
    else
    end
    var $lo : int3d = int3d({x = (($tile.x*$Nx)/$ntx), y = (($tile.y*$Ny)/$nty), z = (((($tile.z-1)*$Nz)/$ntz)+$val)})
    var $hi : int3d = int3d({x = (((($tile.x+1)*$Nx)/$ntx)-1), y = (((($tile.y+1)*$Ny)/$nty)-1), z = (($tile.z*$Nz)/$ntz)})
    if ($lo.z<0) then
      $lo.z = int64(1)
      $hi.z = int64(0)
    else
    end
    var $rect : rect3d = rect3d({lo = $lo, hi = $hi})
    legion_domain_point_coloring_color_domain($coloring, legion_domain_point_t($tile), legion_domain_t($rect))
  end
  var $p : partition(disjoint, $faces, $z_tiles) = partition(disjoint, $faces, $coloring, $z_tiles)
  legion_domain_point_coloring_destroy($coloring)
  return $p
end

__demand(__cuda)
task source_term($points : region(ispace(int3d), Radiation_columns), $angles : region(ispace(int1d), angle), $omega : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($points.Iiter_1), reads($points.Iiter_2), reads($points.Iiter_3), reads($points.Iiter_4), reads($points.Iiter_5), reads($points.Iiter_6), reads($points.Iiter_7), reads($points.Iiter_8), reads($points.Ib), reads($points.sigma), reads($angles.w), reads($points.S), writes($points.S)
do
  __demand(__openmp)
  for $p : int3d(Radiation_columns, $points) in $points do
    (@$p).S = (((1-$omega)*(@$p).sigma)*(@$p).Ib)
    for $m : int32 = 0, 14 do
      (@$p).S += ((((((((((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_1[$m])+(((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_2[$m]))+(((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_3[$m]))+(((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_4[$m]))+(((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_5[$m]))+(((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_6[$m]))+(((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_7[$m]))+(((($omega*(@$p).sigma)/(4*3.1415926535898))*$angles[$m].w)*(@$p).Iiter_8[$m]))
    end
  end
end

task west_bound($faces_1 : region(ispace(int3d), face), $faces_2 : region(ispace(int3d), face), $faces_3 : region(ispace(int3d), face), $faces_4 : region(ispace(int3d), face), $faces_5 : region(ispace(int3d), face), $faces_6 : region(ispace(int3d), face), $faces_7 : region(ispace(int3d), face), $faces_8 : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $emissWest : double, $tempWest : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.w), reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($faces_1.I), reads($faces_2.I), reads($faces_3.I), reads($faces_4.I), reads($faces_5.I), reads($faces_6.I), reads($faces_7.I), reads($faces_8.I), writes($faces_1.I), writes($faces_2.I), writes($faces_3.I), writes($faces_4.I), writes($faces_5.I), writes($faces_6.I), writes($faces_7.I), writes($faces_8.I)
do
  var $limits : rect3d = $faces_1.bounds
  var $reflect : double = 0
  var $epsw : double = $emissWest
  var $Tw : double = $tempWest
  for $j : int64 = $limits.lo.y, ($limits.hi.y+1) do
    for $k : int64 = $limits.lo.z, ($limits.hi.z+1) do
      $reflect = double(0)
      for $m : int32 = 0, 14 do
        if ($angles[$m].xi<0) then
          var $face_value : double = 0
          if (($angles[$m].eta>0) and ($angles[$m].mu>0)) then
            $face_value = $faces_5[{$limits.lo.x, $j, $k}].I[$m]
          elseif (($angles[$m].eta>0) and ($angles[$m].mu<0)) then
            $face_value = $faces_6[{$limits.lo.x, $j, $k}].I[$m]
          elseif (($angles[$m].eta<0) and ($angles[$m].mu>0)) then
            $face_value = $faces_7[{$limits.lo.x, $j, $k}].I[$m]
          else
            $face_value = $faces_8[{$limits.lo.x, $j, $k}].I[$m]
          end
          $reflect += (((((1-$epsw)/3.1415926535898)*$angles[$m].w)*fabs($angles[$m].xi))*$face_value)
        else
        end
      end
      for $m : int32 = 0, 14 do
        if ($angles[$m].xi>0) then
          var $value : double = (((($epsw*5.67e-08)*pow($Tw, 4))/3.1415926535898)+$reflect)
          if (($angles[$m].eta>0) and ($angles[$m].mu>0)) then
            $faces_1[{$limits.lo.x, $j, $k}].I[$m] = $value
          elseif (($angles[$m].eta>0) and ($angles[$m].mu<0)) then
            $faces_2[{$limits.lo.x, $j, $k}].I[$m] = $value
          elseif (($angles[$m].eta<0) and ($angles[$m].mu>0)) then
            $faces_3[{$limits.lo.x, $j, $k}].I[$m] = $value
          else
            $faces_4[{$limits.lo.x, $j, $k}].I[$m] = $value
          end
        else
        end
      end
    end
  end
end

task east_bound($faces_1 : region(ispace(int3d), face), $faces_2 : region(ispace(int3d), face), $faces_3 : region(ispace(int3d), face), $faces_4 : region(ispace(int3d), face), $faces_5 : region(ispace(int3d), face), $faces_6 : region(ispace(int3d), face), $faces_7 : region(ispace(int3d), face), $faces_8 : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $emissEast : double, $tempEast : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.w), reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($faces_1.I), reads($faces_2.I), reads($faces_3.I), reads($faces_4.I), reads($faces_5.I), reads($faces_6.I), reads($faces_7.I), reads($faces_8.I), writes($faces_1.I), writes($faces_2.I), writes($faces_3.I), writes($faces_4.I), writes($faces_5.I), writes($faces_6.I), writes($faces_7.I), writes($faces_8.I)
do
  var $limits : rect3d = $faces_1.bounds
  var $reflect : double = 0
  var $epsw : double = $emissEast
  var $Tw : double = $tempEast
  for $j : int64 = $limits.lo.y, ($limits.hi.y+1) do
    for $k : int64 = $limits.lo.z, ($limits.hi.z+1) do
      $reflect = double(0)
      for $m : int32 = 0, 14 do
        if ($angles[$m].xi>0) then
          var $face_value : double = 0
          if (($angles[$m].eta>0) and ($angles[$m].mu>0)) then
            $face_value = $faces_1[{$limits.hi.x, $j, $k}].I[$m]
          elseif (($angles[$m].eta>0) and ($angles[$m].mu<0)) then
            $face_value = $faces_2[{$limits.hi.x, $j, $k}].I[$m]
          elseif (($angles[$m].eta<0) and ($angles[$m].mu>0)) then
            $face_value = $faces_3[{$limits.hi.x, $j, $k}].I[$m]
          else
            $face_value = $faces_4[{$limits.hi.x, $j, $k}].I[$m]
          end
          $reflect += (((((1-$epsw)/3.1415926535898)*$angles[$m].w)*$angles[$m].xi)*$face_value)
        else
        end
      end
      for $m : int32 = 0, 14 do
        if ($angles[$m].xi<0) then
          var $value : double = (((($epsw*5.67e-08)*pow($Tw, 4))/3.1415926535898)+$reflect)
          if (($angles[$m].eta>0) and ($angles[$m].mu>0)) then
            $faces_5[{$limits.hi.x, $j, $k}].I[$m] = $value
          elseif (($angles[$m].eta>0) and ($angles[$m].mu<0)) then
            $faces_6[{$limits.hi.x, $j, $k}].I[$m] = $value
          elseif (($angles[$m].eta<0) and ($angles[$m].mu>0)) then
            $faces_7[{$limits.hi.x, $j, $k}].I[$m] = $value
          else
            $faces_8[{$limits.hi.x, $j, $k}].I[$m] = $value
          end
        else
        end
      end
    end
  end
end

task north_bound($faces_1 : region(ispace(int3d), face), $faces_2 : region(ispace(int3d), face), $faces_3 : region(ispace(int3d), face), $faces_4 : region(ispace(int3d), face), $faces_5 : region(ispace(int3d), face), $faces_6 : region(ispace(int3d), face), $faces_7 : region(ispace(int3d), face), $faces_8 : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $emissNorth : double, $tempNorth : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.w), reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($faces_1.I), reads($faces_2.I), reads($faces_3.I), reads($faces_4.I), reads($faces_5.I), reads($faces_6.I), reads($faces_7.I), reads($faces_8.I), writes($faces_1.I), writes($faces_2.I), writes($faces_3.I), writes($faces_4.I), writes($faces_5.I), writes($faces_6.I), writes($faces_7.I), writes($faces_8.I)
do
  var $limits : rect3d = $faces_1.bounds
  var $reflect : double = 0
  var $epsw : double = $emissNorth
  var $Tw : double = $tempNorth
  for $i : int64 = $limits.lo.x, ($limits.hi.x+1) do
    for $k : int64 = $limits.lo.z, ($limits.hi.z+1) do
      $reflect = double(0)
      for $m : int32 = 0, 14 do
        if ($angles[$m].eta>0) then
          var $face_value : double = 0
          if (($angles[$m].xi>0) and ($angles[$m].mu>0)) then
            $face_value = $faces_1[{$i, $limits.hi.y, $k}].I[$m]
          elseif (($angles[$m].xi>0) and ($angles[$m].mu<0)) then
            $face_value = $faces_2[{$i, $limits.hi.y, $k}].I[$m]
          elseif (($angles[$m].xi<0) and ($angles[$m].mu>0)) then
            $face_value = $faces_5[{$i, $limits.hi.y, $k}].I[$m]
          else
            $face_value = $faces_6[{$i, $limits.hi.y, $k}].I[$m]
          end
          $reflect += (((((1-$epsw)/3.1415926535898)*$angles[$m].w)*$angles[$m].eta)*$face_value)
        else
        end
      end
      for $m : int32 = 0, 14 do
        if ($angles[$m].eta<0) then
          var $value : double = (((($epsw*5.67e-08)*pow($Tw, 4))/3.1415926535898)+$reflect)
          if (($angles[$m].xi>0) and ($angles[$m].mu>0)) then
            $faces_3[{$i, $limits.hi.y, $k}].I[$m] = $value
          elseif (($angles[$m].xi>0) and ($angles[$m].mu<0)) then
            $faces_4[{$i, $limits.hi.y, $k}].I[$m] = $value
          elseif (($angles[$m].xi<0) and ($angles[$m].mu>0)) then
            $faces_7[{$i, $limits.hi.y, $k}].I[$m] = $value
          else
            $faces_8[{$i, $limits.hi.y, $k}].I[$m] = $value
          end
        else
        end
      end
    end
  end
end

task south_bound($faces_1 : region(ispace(int3d), face), $faces_2 : region(ispace(int3d), face), $faces_3 : region(ispace(int3d), face), $faces_4 : region(ispace(int3d), face), $faces_5 : region(ispace(int3d), face), $faces_6 : region(ispace(int3d), face), $faces_7 : region(ispace(int3d), face), $faces_8 : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $emissSouth : double, $tempSouth : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.w), reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($faces_1.I), reads($faces_2.I), reads($faces_3.I), reads($faces_4.I), reads($faces_5.I), reads($faces_6.I), reads($faces_7.I), reads($faces_8.I), writes($faces_1.I), writes($faces_2.I), writes($faces_3.I), writes($faces_4.I), writes($faces_5.I), writes($faces_6.I), writes($faces_7.I), writes($faces_8.I)
do
  var $limits : rect3d = $faces_1.bounds
  var $reflect : double = 0
  var $epsw : double = $emissSouth
  var $Tw : double = $tempSouth
  for $i : int64 = $limits.lo.x, ($limits.hi.x+1) do
    for $k : int64 = $limits.lo.z, ($limits.hi.z+1) do
      $reflect = double(0)
      for $m : int32 = 0, 14 do
        if ($angles[$m].eta<0) then
          var $face_value : double = 0
          if (($angles[$m].xi>0) and ($angles[$m].mu>0)) then
            $face_value = $faces_3[{$i, $limits.lo.y, $k}].I[$m]
          elseif (($angles[$m].xi>0) and ($angles[$m].mu<0)) then
            $face_value = $faces_4[{$i, $limits.lo.y, $k}].I[$m]
          elseif (($angles[$m].xi<0) and ($angles[$m].mu>0)) then
            $face_value = $faces_7[{$i, $limits.lo.y, $k}].I[$m]
          else
            $face_value = $faces_8[{$i, $limits.lo.y, $k}].I[$m]
          end
          $reflect += (((((1-$epsw)/3.1415926535898)*$angles[$m].w)*fabs($angles[$m].eta))*$face_value)
        else
        end
      end
      for $m : int32 = 0, 14 do
        if ($angles[$m].eta>0) then
          var $value : double = (((($epsw*5.67e-08)*pow($Tw, 4))/3.1415926535898)+$reflect)
          if (($angles[$m].xi>0) and ($angles[$m].mu>0)) then
            $faces_1[{$i, $limits.lo.y, $k}].I[$m] = $value
          elseif (($angles[$m].xi>0) and ($angles[$m].mu<0)) then
            $faces_2[{$i, $limits.lo.y, $k}].I[$m] = $value
          elseif (($angles[$m].xi<0) and ($angles[$m].mu>0)) then
            $faces_5[{$i, $limits.lo.y, $k}].I[$m] = $value
          else
            $faces_6[{$i, $limits.lo.y, $k}].I[$m] = $value
          end
        else
        end
      end
    end
  end
end

task up_bound($faces_1 : region(ispace(int3d), face), $faces_2 : region(ispace(int3d), face), $faces_3 : region(ispace(int3d), face), $faces_4 : region(ispace(int3d), face), $faces_5 : region(ispace(int3d), face), $faces_6 : region(ispace(int3d), face), $faces_7 : region(ispace(int3d), face), $faces_8 : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $emissUp : double, $tempUp : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.w), reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($faces_1.I), reads($faces_2.I), reads($faces_3.I), reads($faces_4.I), reads($faces_5.I), reads($faces_6.I), reads($faces_7.I), reads($faces_8.I), writes($faces_1.I), writes($faces_2.I), writes($faces_3.I), writes($faces_4.I), writes($faces_5.I), writes($faces_6.I), writes($faces_7.I), writes($faces_8.I)
do
  var $limits : rect3d = $faces_1.bounds
  var $reflect : double = 0
  var $epsw : double = $emissUp
  var $Tw : double = $tempUp
  for $i : int64 = $limits.lo.x, ($limits.hi.x+1) do
    for $j : int64 = $limits.lo.y, ($limits.hi.y+1) do
      $reflect = double(0)
      for $m : int32 = 0, 14 do
        if ($angles[$m].mu<0) then
          var $face_value : double = 0
          if (($angles[$m].xi>0) and ($angles[$m].eta>0)) then
            $face_value = $faces_2[{$i, $j, $limits.lo.z}].I[$m]
          elseif (($angles[$m].xi>0) and ($angles[$m].eta<0)) then
            $face_value = $faces_4[{$i, $j, $limits.lo.z}].I[$m]
          elseif (($angles[$m].xi<0) and ($angles[$m].eta>0)) then
            $face_value = $faces_6[{$i, $j, $limits.lo.z}].I[$m]
          else
            $face_value = $faces_8[{$i, $j, $limits.lo.z}].I[$m]
          end
          $reflect += (((((1-$epsw)/3.1415926535898)*$angles[$m].w)*fabs($angles[$m].mu))*$face_value)
        else
        end
      end
      for $m : int32 = 0, 14 do
        if ($angles[$m].mu>0) then
          var $value : double = (((($epsw*5.67e-08)*pow($Tw, 4))/3.1415926535898)+$reflect)
          if (($angles[$m].xi>0) and ($angles[$m].eta>0)) then
            $faces_1[{$i, $j, $limits.lo.z}].I[$m] = $value
          elseif (($angles[$m].xi>0) and ($angles[$m].eta<0)) then
            $faces_3[{$i, $j, $limits.lo.z}].I[$m] = $value
          elseif (($angles[$m].xi<0) and ($angles[$m].eta>0)) then
            $faces_5[{$i, $j, $limits.lo.z}].I[$m] = $value
          else
            $faces_7[{$i, $j, $limits.lo.z}].I[$m] = $value
          end
        else
        end
      end
    end
  end
end

task down_bound($faces_1 : region(ispace(int3d), face), $faces_2 : region(ispace(int3d), face), $faces_3 : region(ispace(int3d), face), $faces_4 : region(ispace(int3d), face), $faces_5 : region(ispace(int3d), face), $faces_6 : region(ispace(int3d), face), $faces_7 : region(ispace(int3d), face), $faces_8 : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $emissDown : double, $tempDown : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.w), reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($faces_1.I), reads($faces_2.I), reads($faces_3.I), reads($faces_4.I), reads($faces_5.I), reads($faces_6.I), reads($faces_7.I), reads($faces_8.I), writes($faces_1.I), writes($faces_2.I), writes($faces_3.I), writes($faces_4.I), writes($faces_5.I), writes($faces_6.I), writes($faces_7.I), writes($faces_8.I)
do
  var $limits : rect3d = $faces_1.bounds
  var $reflect : double = 0
  var $epsw : double = $emissDown
  var $Tw : double = $tempDown
  for $i : int64 = $limits.lo.x, ($limits.hi.x+1) do
    for $j : int64 = $limits.lo.y, ($limits.hi.y+1) do
      $reflect = double(0)
      for $m : int32 = 0, 14 do
        if ($angles[$m].mu>0) then
          var $face_value : double = 0
          if (($angles[$m].xi>0) and ($angles[$m].eta>0)) then
            $face_value = $faces_1[{$i, $j, $limits.hi.z}].I[$m]
          elseif (($angles[$m].xi>0) and ($angles[$m].eta<0)) then
            $face_value = $faces_3[{$i, $j, $limits.hi.z}].I[$m]
          elseif (($angles[$m].xi<0) and ($angles[$m].eta>0)) then
            $face_value = $faces_5[{$i, $j, $limits.hi.z}].I[$m]
          else
            $face_value = $faces_7[{$i, $j, $limits.hi.z}].I[$m]
          end
          $reflect += (((((1-$epsw)/3.1415926535898)*$angles[$m].w)*$angles[$m].mu)*$face_value)
        else
        end
      end
      for $m : int32 = 0, 14 do
        if ($angles[$m].mu<0) then
          var $value : double = (((($epsw*5.67e-08)*pow($Tw, 4))/3.1415926535898)+$reflect)
          if (($angles[$m].xi>0) and ($angles[$m].eta>0)) then
            $faces_2[{$i, $j, $limits.hi.z}].I[$m] = $value
          elseif (($angles[$m].xi>0) and ($angles[$m].eta<0)) then
            $faces_4[{$i, $j, $limits.hi.z}].I[$m] = $value
          elseif (($angles[$m].xi<0) and ($angles[$m].eta>0)) then
            $faces_6[{$i, $j, $limits.hi.z}].I[$m] = $value
          else
            $faces_8[{$i, $j, $limits.hi.z}].I[$m] = $value
          end
        else
        end
      end
    end
  end
end

task sweep_1($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_1), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_1), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_1[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_1[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_1[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_1[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

task sweep_2($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_2), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_2), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_2[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_2[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_2[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_2[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

task sweep_3($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_3), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_3), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_3[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_3[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_3[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_3[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

task sweep_4($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_4), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_4), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_4[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_4[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_4[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_4[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

task sweep_5($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_5), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_5), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_5[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_5[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_5[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_5[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

task sweep_6($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_6), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_6), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_6[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_6[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_6[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_6[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

task sweep_7($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_7), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_7), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_7[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_7[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_7[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_7[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

task sweep_8($points : region(ispace(int3d), Radiation_columns), $x_faces : region(ispace(int3d), face), $y_faces : region(ispace(int3d), face), $z_faces : region(ispace(int3d), face), $ghost_x_faces : region(ispace(int3d), face), $ghost_y_faces : region(ispace(int3d), face), $ghost_z_faces : region(ispace(int3d), face), $angles : region(ispace(int1d), angle), $xi : int64, $eta : int64, $mu : int64, $dx : double, $dy : double, $dz : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($angles.xi), reads($angles.eta), reads($angles.mu), reads($points.S), reads($points.sigma), reads($ghost_x_faces.I), reads($ghost_y_faces.I), reads($ghost_z_faces.I), reads($points.I_8), reads($x_faces.I), reads($y_faces.I), reads($z_faces.I), writes($points.I_8), writes($x_faces.I), writes($y_faces.I), writes($z_faces.I)
do
  var $dAx : double = ($dy*$dz)
  var $dAy : double = ($dx*$dz)
  var $dAz : double = ($dx*$dy)
  var $dV : double = (($dx*$dy)*$dz)
  var $limits : rect3d = $points.bounds
  var $dindx : int64 = int64(1)
  var $startx : int64 = $limits.lo.x
  var $endx : int64 = ($limits.hi.x+1)
  var $dindy : int64 = int64(1)
  var $starty : int64 = $limits.lo.y
  var $endy : int64 = ($limits.hi.y+1)
  var $dindz : int64 = int64(1)
  var $startz : int64 = $limits.lo.z
  var $endz : int64 = ($limits.hi.z+1)
  if ($xi<0) then
    $dindx = int64((-1))
    $startx = $limits.hi.x
    $endx = ($limits.lo.x-1)
  else
  end
  if ($eta<0) then
    $dindy = int64((-1))
    $starty = $limits.hi.y
    $endy = ($limits.lo.y-1)
  else
  end
  if ($mu<0) then
    $dindz = int64((-1))
    $startz = $limits.hi.z
    $endz = ($limits.lo.z-1)
  else
  end
  for $m : int32 = 0, 14 do
    if ((((($angles[$m].xi*$xi)>0) or (($angles[$m].xi==0) and ($xi<0))) and ((($angles[$m].eta*$eta)>0) or (($angles[$m].eta==0) and ($eta<0)))) and ((($angles[$m].mu*$mu)>0) or (($angles[$m].mu==0) and ($mu<0)))) then
      for $k : int64 = $startz, $endz, $dindz do
        for $j : int64 = $starty, $endy, $dindy do
          for $i : int64 = $startx, $endx, $dindx do
            var $indx : int64 = ($i-min($dindx, 0))
            var $indy : int64 = ($j-min($dindy, 0))
            var $indz : int64 = ($k-min($dindz, 0))
            var $ghost_x_limits : rect3d = $ghost_x_faces.bounds
            var $upwind_x_value : double = 0
            if ($indx<$x_faces.bounds.lo.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.hi.x, $j, $k}].I[$m]
            elseif ($indx>$x_faces.bounds.hi.x) then
              $upwind_x_value = $ghost_x_faces[{$ghost_x_limits.lo.x, $j, $k}].I[$m]
            else
              $upwind_x_value = $x_faces[{$indx, $j, $k}].I[$m]
            end
            var $ghost_y_limits : rect3d = $ghost_y_faces.bounds
            var $upwind_y_value : double = 0
            if ($indy<$y_faces.bounds.lo.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.hi.y, $k}].I[$m]
            elseif ($indy>$y_faces.bounds.hi.y) then
              $upwind_y_value = $ghost_y_faces[{$i, $ghost_y_limits.lo.y, $k}].I[$m]
            else
              $upwind_y_value = $y_faces[{$i, $indy, $k}].I[$m]
            end
            var $ghost_z_limits : rect3d = $ghost_z_faces.bounds
            var $upwind_z_value : double = 0
            if ($indz<$z_faces.bounds.lo.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.hi.z}].I[$m]
            elseif ($indz>$z_faces.bounds.hi.z) then
              $upwind_z_value = $ghost_z_faces[{$i, $j, $ghost_z_limits.lo.z}].I[$m]
            else
              $upwind_z_value = $z_faces[{$i, $j, $indz}].I[$m]
            end
            $points[{$i, $j, $k}].I_8[$m] = ((((($points[{$i, $j, $k}].S*$dV)+(((fabs($angles[$m].xi)*$dAx)*$upwind_x_value)/0.5))+(((fabs($angles[$m].eta)*$dAy)*$upwind_y_value)/0.5))+(((fabs($angles[$m].mu)*$dAz)*$upwind_z_value)/0.5))/(((($points[{$i, $j, $k}].sigma*$dV)+((fabs($angles[$m].xi)*$dAx)/0.5))+((fabs($angles[$m].eta)*$dAy)/0.5))+((fabs($angles[$m].mu)*$dAz)/0.5)))
            $x_faces[{($indx+$dindx), $j, $k}].I[$m] = (($points[{$i, $j, $k}].I_8[$m]-((1-0.5)*$upwind_x_value))/0.5)
            $y_faces[{$i, ($indy+$dindy), $k}].I[$m] = (($points[{$i, $j, $k}].I_8[$m]-((1-0.5)*$upwind_y_value))/0.5)
            $z_faces[{$i, $j, ($indz+$dindz)}].I[$m] = (($points[{$i, $j, $k}].I_8[$m]-((1-0.5)*$upwind_z_value))/0.5)
          end
        end
      end
    else
    end
  end
end

__demand(__cuda)
task residual($points : region(ispace(int3d), Radiation_columns), $Nx : int32, $Ny : int32, $Nz : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($points.I_1), reads($points.I_2), reads($points.I_3), reads($points.I_4), reads($points.I_5), reads($points.I_6), reads($points.I_7), reads($points.I_8), reads($points.Iiter_1), reads($points.Iiter_2), reads($points.Iiter_3), reads($points.Iiter_4), reads($points.Iiter_5), reads($points.Iiter_6), reads($points.Iiter_7), reads($points.Iiter_8)
do
  var $res : double = 0
  __demand(__openmp)
  for $p : int3d(Radiation_columns, $points) in $points do
    for $m : int32 = 0, 14 do
      if ((@$p).I_1[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_1[$m]-(@$p).Iiter_1[$m]), 2))/pow((@$p).I_1[$m], 2))
      else
      end
      if ((@$p).I_2[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_2[$m]-(@$p).Iiter_2[$m]), 2))/pow((@$p).I_2[$m], 2))
      else
      end
      if ((@$p).I_3[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_3[$m]-(@$p).Iiter_3[$m]), 2))/pow((@$p).I_3[$m], 2))
      else
      end
      if ((@$p).I_4[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_4[$m]-(@$p).Iiter_4[$m]), 2))/pow((@$p).I_4[$m], 2))
      else
      end
      if ((@$p).I_5[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_5[$m]-(@$p).Iiter_5[$m]), 2))/pow((@$p).I_5[$m], 2))
      else
      end
      if ((@$p).I_6[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_6[$m]-(@$p).Iiter_6[$m]), 2))/pow((@$p).I_6[$m], 2))
      else
      end
      if ((@$p).I_7[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_7[$m]-(@$p).Iiter_7[$m]), 2))/pow((@$p).I_7[$m], 2))
      else
      end
      if ((@$p).I_8[$m]>0) then
        $res += (((1/((($Nx*$Ny)*$Nz)*14))*pow(((@$p).I_8[$m]-(@$p).Iiter_8[$m]), 2))/pow((@$p).I_8[$m], 2))
      else
      end
    end
  end
  return $res
end

__demand(__cuda)
task update($points : region(ispace(int3d), Radiation_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($points.I_1), reads($points.I_2), reads($points.I_3), reads($points.I_4), reads($points.I_5), reads($points.I_6), reads($points.I_7), reads($points.I_8), reads($points.Iiter_1), reads($points.Iiter_2), reads($points.Iiter_3), reads($points.Iiter_4), reads($points.Iiter_5), reads($points.Iiter_6), reads($points.Iiter_7), reads($points.Iiter_8), writes($points.Iiter_1), writes($points.Iiter_2), writes($points.Iiter_3), writes($points.Iiter_4), writes($points.Iiter_5), writes($points.Iiter_6), writes($points.Iiter_7), writes($points.Iiter_8)
do
  __demand(__openmp)
  for $p : int3d(Radiation_columns, $points) in $points do
    for $m : int32 = 0, 14 do
      (@$p).Iiter_1[$m] = (@$p).I_1[$m]
      (@$p).Iiter_2[$m] = (@$p).I_2[$m]
      (@$p).Iiter_3[$m] = (@$p).I_3[$m]
      (@$p).Iiter_4[$m] = (@$p).I_4[$m]
      (@$p).Iiter_5[$m] = (@$p).I_5[$m]
      (@$p).Iiter_6[$m] = (@$p).I_6[$m]
      (@$p).Iiter_7[$m] = (@$p).I_7[$m]
      (@$p).Iiter_8[$m] = (@$p).I_8[$m]
    end
  end
end

__demand(__cuda)
task reduce_intensity($points : region(ispace(int3d), Radiation_columns), $angles : region(ispace(int1d), angle))
-- leaf (false), inner (false), idempotent (false)
where
  reads($points.I_1), reads($points.I_2), reads($points.I_3), reads($points.I_4), reads($points.I_5), reads($points.I_6), reads($points.I_7), reads($points.I_8), reads($angles.w), reads($points.G), writes($points.G)
do
  __demand(__openmp)
  for $p : int3d(Radiation_columns, $points) in $points do
    for $m : int32 = 0, 14 do
      (@$p).G += (((((((($angles[$m].w*(@$p).I_1[$m])+($angles[$m].w*(@$p).I_2[$m]))+($angles[$m].w*(@$p).I_3[$m]))+($angles[$m].w*(@$p).I_4[$m]))+($angles[$m].w*(@$p).I_5[$m]))+($angles[$m].w*(@$p).I_6[$m]))+($angles[$m].w*(@$p).I_7[$m]))+($angles[$m].w*(@$p).I_8[$m]))
    end
  end
end

__demand(__parallel, __cuda)
task particles_initValidField($r : region(ispace(int1d), particles_columns))
-- leaf (false), inner (false), idempotent (false)
where
  writes($r.__valid)
do
  __demand(__openmp)
  for $e : int1d(particles_columns, $r) in $r do
    (@$e).__valid = false
  end
end

__demand(__parallel, __cuda)
task SetCoarseningField($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32, $Radiation_xBnum : int32, $Radiation_xNum : int32, $Radiation_yBnum : int32, $Radiation_yNum : int32, $Radiation_zBnum : int32, $Radiation_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.to_Radiation), writes($Fluid.to_Radiation)
do
  __demand(__openmp)
  for $f : int3d(Fluid_columns, $Fluid) in $Fluid do
    var $xFactor : int32 = ($Grid_xNum/$Radiation_xNum)
    var $yFactor : int32 = ($Grid_yNum/$Radiation_yNum)
    var $zFactor : int32 = ($Radiation_zNum/$Radiation_zNum)
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($f).x)), int32(0))>int32(0)) or (max(int32((int3d($f).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($f).y)), int32(0))>int32(0))) or (max(int32((int3d($f).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($f).z)), int32(0))>int32(0))) or (max(int32((int3d($f).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $Fluid[$f].to_Radiation = int3d({(((int3d($f).x-uint64($Grid_xBnum))/uint64($xFactor))+uint64($Radiation_xBnum)), (((int3d($f).y-uint64($Grid_yBnum))/uint64($yFactor))+uint64($Radiation_yBnum)), (((int3d($f).z-uint64($Grid_zBnum))/uint64($zFactor))+uint64($Radiation_zBnum))})
    else
      $Fluid[$f].to_Radiation = int3d({uint64(0ULL), uint64(0ULL), uint64(0ULL)})
    end
  end
end

__demand(__parallel, __cuda)
task Flow_InitializeCell($Fluid : region(ispace(int3d), Fluid_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.PD), writes($Fluid.PD), reads($Fluid.centerCoordinates), writes($Fluid.centerCoordinates), reads($Fluid.convectiveSpectralRadius), writes($Fluid.convectiveSpectralRadius), reads($Fluid.dissipation), writes($Fluid.dissipation), reads($Fluid.dissipationFlux), writes($Fluid.dissipationFlux), reads($Fluid.heatConductionSpectralRadius), writes($Fluid.heatConductionSpectralRadius), reads($Fluid.kineticEnergy), writes($Fluid.kineticEnergy), reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.pressureBoundary), writes($Fluid.pressureBoundary), reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.rhoBoundary), writes($Fluid.rhoBoundary), reads($Fluid.rhoEnergy), writes($Fluid.rhoEnergy), reads($Fluid.rhoEnergyBoundary), writes($Fluid.rhoEnergyBoundary), reads($Fluid.rhoEnergyFluxX), writes($Fluid.rhoEnergyFluxX), reads($Fluid.rhoEnergyFluxY), writes($Fluid.rhoEnergyFluxY), reads($Fluid.rhoEnergyFluxZ), writes($Fluid.rhoEnergyFluxZ), reads($Fluid.rhoEnergy_new), writes($Fluid.rhoEnergy_new), reads($Fluid.rhoEnergy_old), writes($Fluid.rhoEnergy_old), reads($Fluid.rhoEnergy_t), writes($Fluid.rhoEnergy_t), reads($Fluid.rhoEnthalpy), writes($Fluid.rhoEnthalpy), reads($Fluid.rhoFluxX), writes($Fluid.rhoFluxX), reads($Fluid.rhoFluxY), writes($Fluid.rhoFluxY), reads($Fluid.rhoFluxZ), writes($Fluid.rhoFluxZ), reads($Fluid.rhoVelocity), writes($Fluid.rhoVelocity), reads($Fluid.rhoVelocityBoundary), writes($Fluid.rhoVelocityBoundary), reads($Fluid.rhoVelocityFluxX), writes($Fluid.rhoVelocityFluxX), reads($Fluid.rhoVelocityFluxY), writes($Fluid.rhoVelocityFluxY), reads($Fluid.rhoVelocityFluxZ), writes($Fluid.rhoVelocityFluxZ), reads($Fluid.rhoVelocity_new), writes($Fluid.rhoVelocity_new), reads($Fluid.rhoVelocity_old), writes($Fluid.rhoVelocity_old), reads($Fluid.rhoVelocity_t), writes($Fluid.rhoVelocity_t), reads($Fluid.rho_new), writes($Fluid.rho_new), reads($Fluid.rho_old), writes($Fluid.rho_old), reads($Fluid.rho_t), writes($Fluid.rho_t), reads($Fluid.sgsEddyKappa), writes($Fluid.sgsEddyKappa), reads($Fluid.sgsEddyViscosity), writes($Fluid.sgsEddyViscosity), reads($Fluid.sgsEnergy), writes($Fluid.sgsEnergy), reads($Fluid.temperature), writes($Fluid.temperature), reads($Fluid.temperatureBoundary), writes($Fluid.temperatureBoundary), reads($Fluid.velocity), writes($Fluid.velocity), reads($Fluid.velocityBoundary), writes($Fluid.velocityBoundary), reads($Fluid.velocityGradientX), writes($Fluid.velocityGradientX), reads($Fluid.velocityGradientXBoundary), writes($Fluid.velocityGradientXBoundary), reads($Fluid.velocityGradientY), writes($Fluid.velocityGradientY), reads($Fluid.velocityGradientYBoundary), writes($Fluid.velocityGradientYBoundary), reads($Fluid.velocityGradientZ), writes($Fluid.velocityGradientZ), reads($Fluid.velocityGradientZBoundary), writes($Fluid.velocityGradientZBoundary), reads($Fluid.viscousSpectralRadius), writes($Fluid.viscousSpectralRadius)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    $Fluid[$c].rho = double(0)
    $Fluid[$c].pressure = double(0)
    $Fluid[$c].velocity = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].centerCoordinates = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].velocityGradientX = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].velocityGradientY = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].velocityGradientZ = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].temperature = double(0)
    $Fluid[$c].rhoEnthalpy = double(0)
    $Fluid[$c].kineticEnergy = double(0)
    $Fluid[$c].sgsEnergy = double(0)
    $Fluid[$c].sgsEddyViscosity = double(0)
    $Fluid[$c].sgsEddyKappa = double(0)
    $Fluid[$c].convectiveSpectralRadius = double(0)
    $Fluid[$c].viscousSpectralRadius = double(0)
    $Fluid[$c].heatConductionSpectralRadius = double(0)
    $Fluid[$c].rhoVelocity = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergy = double(0)
    $Fluid[$c].rhoBoundary = double(0)
    $Fluid[$c].rhoVelocityBoundary = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergyBoundary = double(0)
    $Fluid[$c].velocityBoundary = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].pressureBoundary = double(0)
    $Fluid[$c].temperatureBoundary = double(0)
    $Fluid[$c].velocityGradientXBoundary = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].velocityGradientYBoundary = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].velocityGradientZBoundary = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rho_old = double(0)
    $Fluid[$c].rhoVelocity_old = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergy_old = double(0)
    $Fluid[$c].rho_new = double(0)
    $Fluid[$c].rhoVelocity_new = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergy_new = double(0)
    $Fluid[$c].rho_t = double(0)
    $Fluid[$c].rhoVelocity_t = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergy_t = double(0)
    $Fluid[$c].rhoFluxX = double(0)
    $Fluid[$c].rhoVelocityFluxX = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergyFluxX = double(0)
    $Fluid[$c].rhoFluxY = double(0)
    $Fluid[$c].rhoVelocityFluxY = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergyFluxY = double(0)
    $Fluid[$c].rhoFluxZ = double(0)
    $Fluid[$c].rhoVelocityFluxZ = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergyFluxZ = double(0)
    $Fluid[$c].PD = double(0)
    $Fluid[$c].dissipation = double(0)
    $Fluid[$c].dissipationFlux = double(0)
  end
end

__demand(__parallel, __cuda)
task Flow_InitializeCenterCoordinates($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_xOrigin : double, $Grid_xWidth : double, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_yOrigin : double, $Grid_yWidth : double, $Grid_zBnum : int32, $Grid_zNum : int32, $Grid_zOrigin : double, $Grid_zWidth : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.centerCoordinates), writes($Fluid.centerCoordinates)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    var $xy : double[3] = double[3](array(($Grid_xOrigin+(($Grid_xWidth/double($Grid_xNum))*(double((int3d($c).x-uint64($Grid_xBnum)))+double(0.5)))), ($Grid_yOrigin+(($Grid_yWidth/double($Grid_yNum))*(double((int3d($c).y-uint64($Grid_yBnum)))+double(0.5)))), ($Grid_zOrigin+(($Grid_zWidth/double($Grid_zNum))*(double((int3d($c).z-uint64($Grid_zBnum)))+double(0.5))))))
    $Fluid[$c].centerCoordinates = double[3](array(double($xy[int32(0)]), double($xy[int32(1)]), double($xy[int32(2)])))
  end
end

__demand(__parallel, __cuda)
task Flow_InitializeUniform($Fluid : region(ispace(int3d), Fluid_columns), $Flow_initParams : double[5])
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.velocity), writes($Fluid.velocity)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    $Fluid[$c].rho = $Flow_initParams[int32(0)]
    $Fluid[$c].pressure = $Flow_initParams[int32(1)]
    $Fluid[$c].velocity[int32(0)] = $Flow_initParams[int32(2)]
    $Fluid[$c].velocity[int32(1)] = $Flow_initParams[int32(3)]
    $Fluid[$c].velocity[int32(2)] = $Flow_initParams[int32(4)]
  end
end

   terra vs_mul_double_3($a : double[3],$b : double) : double[3]
       return array([&double]($a)[0] * $b, [&double]($a)[1] * $b, [&double]($a)[2] * $b)
   end
__demand(__parallel, __cuda)
task Flow_InitializeTaylorGreen2D($Fluid : region(ispace(int3d), Fluid_columns), $Flow_initParams : double[5], $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_xOrigin : double, $Grid_xWidth : double, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_yOrigin : double, $Grid_yWidth : double, $Grid_zBnum : int32, $Grid_zNum : int32, $Grid_zOrigin : double, $Grid_zWidth : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.velocity), writes($Fluid.velocity)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    var $taylorGreenDensity : double = $Flow_initParams[int32(0)]
    var $taylorGreenPressure : double = $Flow_initParams[int32(1)]
    var $taylorGreenVelocity : double = $Flow_initParams[int32(2)]
    var $xy : double[3] = double[3](array(($Grid_xOrigin+(($Grid_xWidth/double($Grid_xNum))*(double((int3d($c).x-uint64($Grid_xBnum)))+double(0.5)))), ($Grid_yOrigin+(($Grid_yWidth/double($Grid_yNum))*(double((int3d($c).y-uint64($Grid_yBnum)))+double(0.5)))), ($Grid_zOrigin+(($Grid_zWidth/double($Grid_zNum))*(double((int3d($c).z-uint64($Grid_zBnum)))+double(0.5))))))
    var $coorZ : int32 = int32(0)
    $Fluid[$c].rho = $taylorGreenDensity
    $Fluid[$c].velocity = vs_mul_double_3(double[3](array((([regentlib.sin(double)]($xy[int32(0)])*[regentlib.cos(double)]($xy[int32(1)]))*[regentlib.cos(double)]($coorZ)), (((-[regentlib.cos(double)]($xy[int32(0)]))*[regentlib.sin(double)]($xy[int32(1)]))*[regentlib.cos(double)]($coorZ)), double(int32(0)))), $taylorGreenVelocity)
    var $factorA : double = ([regentlib.cos(double)]((double(2)*double($coorZ)))+double(2))
    var $factorB : double = ([regentlib.cos(double)]((double(2)*$xy[int32(0)]))+[regentlib.cos(double)]((double(2)*$xy[int32(1)])))
    $Fluid[$c].pressure = ($taylorGreenPressure+(((($taylorGreenDensity*pow($taylorGreenVelocity, double(int32(2))))/double(int32(16)))*$factorA)*$factorB))
  end
end

__demand(__parallel, __cuda)
task Flow_InitializeTaylorGreen3D($Fluid : region(ispace(int3d), Fluid_columns), $Flow_initParams : double[5], $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_xOrigin : double, $Grid_xWidth : double, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_yOrigin : double, $Grid_yWidth : double, $Grid_zBnum : int32, $Grid_zNum : int32, $Grid_zOrigin : double, $Grid_zWidth : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.velocity), writes($Fluid.velocity)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    var $taylorGreenDensity : double = $Flow_initParams[int32(0)]
    var $taylorGreenPressure : double = $Flow_initParams[int32(1)]
    var $taylorGreenVelocity : double = $Flow_initParams[int32(2)]
    var $xy : double[3] = double[3](array(($Grid_xOrigin+(($Grid_xWidth/double($Grid_xNum))*(double((int3d($c).x-uint64($Grid_xBnum)))+double(0.5)))), ($Grid_yOrigin+(($Grid_yWidth/double($Grid_yNum))*(double((int3d($c).y-uint64($Grid_yBnum)))+double(0.5)))), ($Grid_zOrigin+(($Grid_zWidth/double($Grid_zNum))*(double((int3d($c).z-uint64($Grid_zBnum)))+double(0.5))))))
    $Fluid[$c].rho = $taylorGreenDensity
    $Fluid[$c].velocity = vs_mul_double_3(double[3](array((([regentlib.sin(double)]($xy[int32(0)])*[regentlib.cos(double)]($xy[int32(1)]))*[regentlib.cos(double)]($xy[int32(2)])), (((-[regentlib.cos(double)]($xy[int32(0)]))*[regentlib.sin(double)]($xy[int32(1)]))*[regentlib.cos(double)]($xy[int32(2)])), double(int32(0)))), $taylorGreenVelocity)
    var $factorA : double = ([regentlib.cos(double)]((double(2)*$xy[int32(2)]))+double(2))
    var $factorB : double = ([regentlib.cos(double)]((double(2)*$xy[int32(0)]))+[regentlib.cos(double)]((double(2)*$xy[int32(1)])))
    $Fluid[$c].pressure = ($taylorGreenPressure+(((($taylorGreenDensity*pow($taylorGreenVelocity, double(int32(2))))/double(int32(16)))*$factorA)*$factorB))
  end
end

__demand(__parallel)
task Flow_InitializePerturbed($Fluid : region(ispace(int3d), Fluid_columns), $Flow_initParams : double[5])
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.velocity), writes($Fluid.velocity)
do
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    $Fluid[$c].rho = $Flow_initParams[int32(0)]
    $Fluid[$c].pressure = $Flow_initParams[int32(1)]
    $Fluid[$c].velocity[int32(0)] = ($Flow_initParams[int32(2)]+(((double(rand())/2147483647)-double(0.5))*double(10)))
    $Fluid[$c].velocity[int32(1)] = ($Flow_initParams[int32(3)]+(((double(rand())/2147483647)-double(0.5))*double(10)))
    $Fluid[$c].velocity[int32(2)] = ($Flow_initParams[int32(4)]+(((double(rand())/2147483647)-double(0.5))*double(10)))
  end
end

Fluid_load_rho_pressure_velocity = HDF.mkLoad(int3d, int3d, Fluid_columns, {"rho","pressure","velocity"})
   terra dot_double_3($a : double[3],$b : double[3]) : double
       return [&double]($a)[0] * [&double]($b)[0] + [&double]($a)[1] * [&double]($b)[1] + [&double]($a)[2] * [&double]($b)[2]
   end
__demand(__parallel, __cuda)
task Flow_UpdateConservedFromPrimitive($Fluid : region(ispace(int3d), Fluid_columns), $Flow_gamma : double, $Flow_gasConstant : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.rho), reads($Fluid.rhoEnergy), writes($Fluid.rhoEnergy), reads($Fluid.rhoVelocity), writes($Fluid.rhoVelocity), reads($Fluid.sgsEnergy), reads($Fluid.velocity)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      var $tmpTemperature : double = ($Fluid[$c].pressure/($Flow_gasConstant*$Fluid[$c].rho))
      var $velocity : double[3] = $Fluid[$c].velocity
      $Fluid[$c].rhoVelocity = vs_mul_double_3($Fluid[$c].velocity, $Fluid[$c].rho)
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      $Fluid[$c].rhoEnergy = (($Fluid[$c].rho*(($cv*$tmpTemperature)+(double(0.5)*dot_double_3($velocity, $velocity))))+$Fluid[$c].sgsEnergy)
    else
    end
  end
end

   terra vs_div_double_3($a : double[3],$b : double) : double[3]
       return array([&double]($a)[0] / $b, [&double]($a)[1] / $b, [&double]($a)[2] / $b)
   end
__demand(__parallel, __cuda)
task Flow_UpdateAuxiliaryVelocity($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.kineticEnergy), writes($Fluid.kineticEnergy), reads($Fluid.rho), reads($Fluid.rhoVelocity), reads($Fluid.velocity), writes($Fluid.velocity)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      var $velocity : double[3] = vs_div_double_3($Fluid[$c].rhoVelocity, $Fluid[$c].rho)
      $Fluid[$c].velocity = $velocity
      $Fluid[$c].kineticEnergy = ((double(0.5)*$Fluid[$c].rho)*dot_double_3($velocity, $velocity))
    else
    end
  end
end

   terra vv_mul_double_3($a : double[3],$b : double[3]) : double[3]
       return array([&double]($a)[0] * [&double]($b)[0], [&double]($a)[1] * [&double]($b)[1], [&double]($a)[2] * [&double]($b)[2])
   end
   terra vv_add_double_3($a : double[3],$b : double[3]) : double[3]
       return array([&double]($a)[0] + [&double]($b)[0], [&double]($a)[1] + [&double]($b)[1], [&double]($a)[2] + [&double]($b)[2])
   end
__demand(__parallel, __cuda)
task Flow_UpdateGhostConservedStep1($Fluid : region(ispace(int3d), Fluid_columns), $BC_xNegTemperature : double, $BC_xNegVelocity : double[3], $BC_xPosTemperature : double, $BC_xPosVelocity : double[3], $BC_xSign : double[3], $BC_yNegTemperature : double, $BC_yNegVelocity : double[3], $BC_yPosTemperature : double, $BC_yPosVelocity : double[3], $BC_ySign : double[3], $BC_zNegTemperature : double, $BC_zNegVelocity : double[3], $BC_zPosTemperature : double, $BC_zPosVelocity : double[3], $BC_zSign : double[3], $Flow_gamma : double, $Flow_gasConstant : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.rho), reads($Fluid.rhoBoundary), writes($Fluid.rhoBoundary), reads($Fluid.rhoEnergyBoundary), writes($Fluid.rhoEnergyBoundary), reads($Fluid.rhoVelocity), reads($Fluid.rhoVelocityBoundary), writes($Fluid.rhoVelocityBoundary), reads($Fluid.temperature)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      var $bnd_velocity : double[3] = $BC_xNegVelocity
      var $bnd_temperature : double = $BC_xNegTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      var $velocity#3505 : double[3] = double[3](array(double(0), double(0), double(0)))
      $velocity#3505 = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity#3505, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity#3505, $velocity#3505))))
    else
    end
    if (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{-1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      var $bnd_velocity : double[3] = $BC_xPosVelocity
      var $bnd_temperature : double = $BC_xPosTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      var $velocity#3516 : double[3] = double[3](array(double(0), double(0), double(0)))
      $velocity#3516 = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity#3516, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity#3516, $velocity#3516))))
    else
    end
    if (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      var $bnd_velocity : double[3] = $BC_yNegVelocity
      var $bnd_temperature : double = $BC_yNegTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      var $velocity#3527 : double[3] = double[3](array(double(0), double(0), double(0)))
      $velocity#3527 = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity#3527, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity#3527, $velocity#3527))))
    else
    end
    if (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, -1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      var $bnd_velocity : double[3] = $BC_yPosVelocity
      var $bnd_temperature : double = $BC_yPosTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      var $velocity#3538 : double[3] = double[3](array(double(0), double(0), double(0)))
      $velocity#3538 = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity#3538, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity#3538, $velocity#3538))))
    else
    end
    if (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, 1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      var $bnd_velocity : double[3] = $BC_zNegVelocity
      var $bnd_temperature : double = $BC_zNegTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      var $velocity#3549 : double[3] = double[3](array(double(0), double(0), double(0)))
      $velocity#3549 = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity#3549, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity#3549, $velocity#3549))))
    else
    end
    if (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, -1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      var $bnd_velocity : double[3] = $BC_zPosVelocity
      var $bnd_temperature : double = $BC_zPosTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      var $velocity#3560 : double[3] = double[3](array(double(0), double(0), double(0)))
      $velocity#3560 = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity#3560, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity#3560, $velocity#3560))))
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostConservedStep2($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.rhoBoundary), reads($Fluid.rhoEnergy), writes($Fluid.rhoEnergy), reads($Fluid.rhoEnergyBoundary), reads($Fluid.rhoVelocity), writes($Fluid.rhoVelocity), reads($Fluid.rhoVelocityBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0))) then
      $Fluid[$c].rho = $Fluid[$c].rhoBoundary
      $Fluid[$c].rhoVelocity = $Fluid[$c].rhoVelocityBoundary
      $Fluid[$c].rhoEnergy = $Fluid[$c].rhoEnergyBoundary
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostVelocityStep1($Fluid : region(ispace(int3d), Fluid_columns), $BC_xNegVelocity : double[3], $BC_xPosVelocity : double[3], $BC_xSign : double[3], $BC_yNegVelocity : double[3], $BC_yPosVelocity : double[3], $BC_ySign : double[3], $BC_zNegVelocity : double[3], $BC_zPosVelocity : double[3], $BC_zSign : double[3], $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.velocity), reads($Fluid.velocityBoundary), writes($Fluid.velocityBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      var $bnd_velocity : double[3] = $BC_xNegVelocity
      $Fluid[$c_bnd].velocityBoundary = vv_add_double_3(vv_mul_double_3($Fluid[$c_int].velocity, $sign), $bnd_velocity)
    else
    end
    if (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{-1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      var $bnd_velocity : double[3] = $BC_xPosVelocity
      $Fluid[$c_bnd].velocityBoundary = vv_add_double_3(vv_mul_double_3($Fluid[$c_int].velocity, $sign), $bnd_velocity)
    else
    end
    if (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      var $bnd_velocity : double[3] = $BC_yNegVelocity
      $Fluid[$c_bnd].velocityBoundary = vv_add_double_3(vv_mul_double_3($Fluid[$c_int].velocity, $sign), $bnd_velocity)
    else
    end
    if (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, -1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      var $bnd_velocity : double[3] = $BC_yPosVelocity
      $Fluid[$c_bnd].velocityBoundary = vv_add_double_3(vv_mul_double_3($Fluid[$c_int].velocity, $sign), $bnd_velocity)
    else
    end
    if (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, 1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      var $bnd_velocity : double[3] = $BC_zNegVelocity
      $Fluid[$c_bnd].velocityBoundary = vv_add_double_3(vv_mul_double_3($Fluid[$c_int].velocity, $sign), $bnd_velocity)
    else
    end
    if (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, -1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      var $bnd_velocity : double[3] = $BC_zPosVelocity
      $Fluid[$c_bnd].velocityBoundary = vv_add_double_3(vv_mul_double_3($Fluid[$c_int].velocity, $sign), $bnd_velocity)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostVelocityStep2($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.velocity), writes($Fluid.velocity), reads($Fluid.velocityBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0))) then
      $Fluid[$c].velocity = $Fluid[$c].velocityBoundary
    else
    end
  end
end

   terra vv_sub_double_3($a : double[3],$b : double[3]) : double[3]
       return array([&double]($a)[0] - [&double]($b)[0], [&double]($a)[1] - [&double]($b)[1], [&double]($a)[2] - [&double]($b)[2])
   end
__demand(__parallel, __cuda)
task Flow_ComputeVelocityGradientAll($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xCellWidth : double, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yCellWidth : double, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zCellWidth : double, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.velocity), reads($Fluid.velocityGradientX), writes($Fluid.velocityGradientX), reads($Fluid.velocityGradientY), writes($Fluid.velocityGradientY), reads($Fluid.velocityGradientZ), writes($Fluid.velocityGradientZ)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $Fluid[$c].velocityGradientX = vs_div_double_3(vs_mul_double_3(vv_sub_double_3($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity, $Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].velocity), double(0.5)), $Grid_xCellWidth)
      $Fluid[$c].velocityGradientY = vs_div_double_3(vs_mul_double_3(vv_sub_double_3($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity, $Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].velocity), double(0.5)), $Grid_yCellWidth)
      $Fluid[$c].velocityGradientZ = vs_div_double_3(vs_mul_double_3(vv_sub_double_3($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity, $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].velocity), double(0.5)), $Grid_zCellWidth)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateAuxiliaryThermodynamics($Fluid : region(ispace(int3d), Fluid_columns), $Flow_gamma : double, $Flow_gasConstant : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.rho), reads($Fluid.rhoEnergy), reads($Fluid.temperature), writes($Fluid.temperature), reads($Fluid.velocity)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      var $kineticEnergy : double = ((double(0.5)*$Fluid[$c].rho)*dot_double_3($Fluid[$c].velocity, $Fluid[$c].velocity))
      var $pressure : double = (($Flow_gamma-double(1))*($Fluid[$c].rhoEnergy-$kineticEnergy))
      $Fluid[$c].pressure = $pressure
      $Fluid[$c].temperature = ($pressure/($Flow_gasConstant*$Fluid[$c].rho))
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostThermodynamicsStep1($Fluid : region(ispace(int3d), Fluid_columns), $BC_xNegTemperature : double, $BC_xPosTemperature : double, $BC_yNegTemperature : double, $BC_yPosTemperature : double, $BC_zNegTemperature : double, $BC_zPosTemperature : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.pressureBoundary), writes($Fluid.pressureBoundary), reads($Fluid.temperature), reads($Fluid.temperatureBoundary), writes($Fluid.temperatureBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{1, 0, 0})%$Fluid.bounds)
      var $bnd_temperature : double = $BC_xNegTemperature
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{-1, 0, 0})%$Fluid.bounds)
      var $bnd_temperature : double = $BC_xPosTemperature
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 1, 0})%$Fluid.bounds)
      var $bnd_temperature : double = $BC_yNegTemperature
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, -1, 0})%$Fluid.bounds)
      var $bnd_temperature : double = $BC_yPosTemperature
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, 1})%$Fluid.bounds)
      var $bnd_temperature : double = $BC_zNegTemperature
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, -1})%$Fluid.bounds)
      var $bnd_temperature : double = $BC_zPosTemperature
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostThermodynamicsStep2($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.pressureBoundary), reads($Fluid.temperature), writes($Fluid.temperature), reads($Fluid.temperatureBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0))) then
      $Fluid[$c].pressure = $Fluid[$c].pressureBoundary
      $Fluid[$c].temperature = $Fluid[$c].temperatureBoundary
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostFieldsStep1($Fluid : region(ispace(int3d), Fluid_columns), $BC_xNegTemperature : double, $BC_xNegVelocity : double[3], $BC_xPosTemperature : double, $BC_xPosVelocity : double[3], $BC_xSign : double[3], $BC_yNegTemperature : double, $BC_yNegVelocity : double[3], $BC_yPosTemperature : double, $BC_yPosVelocity : double[3], $BC_ySign : double[3], $BC_zNegTemperature : double, $BC_zNegVelocity : double[3], $BC_zPosTemperature : double, $BC_zPosVelocity : double[3], $BC_zSign : double[3], $Flow_gamma : double, $Flow_gasConstant : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.pressureBoundary), writes($Fluid.pressureBoundary), reads($Fluid.rho), reads($Fluid.rhoBoundary), writes($Fluid.rhoBoundary), reads($Fluid.rhoEnergyBoundary), writes($Fluid.rhoEnergyBoundary), reads($Fluid.rhoVelocity), reads($Fluid.rhoVelocityBoundary), writes($Fluid.rhoVelocityBoundary), reads($Fluid.temperature), reads($Fluid.temperatureBoundary), writes($Fluid.temperatureBoundary), reads($Fluid.velocityBoundary), writes($Fluid.velocityBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      var $bnd_velocity : double[3] = $BC_xNegVelocity
      var $bnd_temperature : double = $BC_xNegTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      $velocity = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity, $velocity))))
      $Fluid[$c_bnd].velocityBoundary = $velocity
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{-1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      var $bnd_velocity : double[3] = $BC_xPosVelocity
      var $bnd_temperature : double = $BC_xPosTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      $velocity = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity, $velocity))))
      $Fluid[$c_bnd].velocityBoundary = $velocity
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      var $bnd_velocity : double[3] = $BC_yNegVelocity
      var $bnd_temperature : double = $BC_yNegTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      $velocity = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity, $velocity))))
      $Fluid[$c_bnd].velocityBoundary = $velocity
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, -1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      var $bnd_velocity : double[3] = $BC_yPosVelocity
      var $bnd_temperature : double = $BC_yPosTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      $velocity = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity, $velocity))))
      $Fluid[$c_bnd].velocityBoundary = $velocity
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, 1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      var $bnd_velocity : double[3] = $BC_zNegVelocity
      var $bnd_temperature : double = $BC_zNegTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      $velocity = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity, $velocity))))
      $Fluid[$c_bnd].velocityBoundary = $velocity
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
    if (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, -1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      var $bnd_velocity : double[3] = $BC_zPosVelocity
      var $bnd_temperature : double = $BC_zPosTemperature
      var $rho : double = double(double(0))
      var $temp_wall : double = double(double(0))
      var $temperature : double = double(double(0))
      var $velocity : double[3] = double[3](array(double(0), double(0), double(0)))
      var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
      $velocity = vv_add_double_3(vv_mul_double_3(vs_div_double_3($Fluid[$c_int].rhoVelocity, $Fluid[$c_int].rho), $sign), $bnd_velocity)
      $temp_wall = $Fluid[$c_int].temperature
      if ($bnd_temperature>double(0)) then
        $temp_wall = $bnd_temperature
      else
      end
      $temperature = ((double(2)*$temp_wall)-$Fluid[$c_int].temperature)
      $rho = ($Fluid[$c_int].pressure/($Flow_gasConstant*$temperature))
      $Fluid[$c_bnd].rhoBoundary = $rho
      $Fluid[$c_bnd].rhoVelocityBoundary = vs_mul_double_3($velocity, $rho)
      $Fluid[$c_bnd].rhoEnergyBoundary = ($rho*(($cv*$temperature)+(double(0.5)*dot_double_3($velocity, $velocity))))
      $Fluid[$c_bnd].velocityBoundary = $velocity
      $Fluid[$c_bnd].pressureBoundary = $Fluid[$c_int].pressure
      $Fluid[$c_bnd].temperatureBoundary = $temperature
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostFieldsStep2($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), writes($Fluid.pressure), reads($Fluid.pressureBoundary), reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.rhoBoundary), reads($Fluid.rhoEnergy), writes($Fluid.rhoEnergy), reads($Fluid.rhoEnergyBoundary), reads($Fluid.rhoVelocity), writes($Fluid.rhoVelocity), reads($Fluid.rhoVelocityBoundary), reads($Fluid.temperature), writes($Fluid.temperature), reads($Fluid.temperatureBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0))) then
      $Fluid[$c].rho = $Fluid[$c].rhoBoundary
      $Fluid[$c].rhoVelocity = $Fluid[$c].rhoVelocityBoundary
      $Fluid[$c].rhoEnergy = $Fluid[$c].rhoEnergyBoundary
      $Fluid[$c].pressure = $Fluid[$c].pressureBoundary
      $Fluid[$c].temperature = $Fluid[$c].temperatureBoundary
    else
    end
  end
end

particles_load_cell_position_velocity_temperature_diameter___valid = HDF.mkLoad(int1d, int3d, particles_columns, {"cell","position","velocity","temperature","diameter","__valid"})
__demand(__parallel, __cuda)
task Particles_InitializeDensity($particles : region(ispace(int1d), particles_columns), $Particles_density : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.density), writes($particles.density), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $particles[$p].density = $Particles_density
    else
    end
  end
end

__demand(__parallel)
task Particles_CalculateNumber($particles : region(ispace(int1d), particles_columns)) : int64
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.__valid)
do
  var $acc : int64 = int64(0)
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $acc += int64(int32(1))
    else
    end
  end
  return $acc
end

__demand(__parallel)
task CalculateAveragePressure($Fluid : region(ispace(int3d), Fluid_columns), $Grid_cellVolume : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc += ($Fluid[$c].pressure*$Grid_cellVolume)
    else
    end
  end
  return $acc
end

__demand(__parallel)
task CalculateAverageTemperature($Fluid : region(ispace(int3d), Fluid_columns), $Grid_cellVolume : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.temperature)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc += ($Fluid[$c].temperature*$Grid_cellVolume)
    else
    end
  end
  return $acc
end

__demand(__parallel)
task CalculateAverageKineticEnergy($Fluid : region(ispace(int3d), Fluid_columns), $Grid_cellVolume : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.kineticEnergy)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc += ($Fluid[$c].kineticEnergy*$Grid_cellVolume)
    else
    end
  end
  return $acc
end

__demand(__parallel)
task CalculateMinTemperature($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.temperature)
do
  var $acc : double = inf
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc min= $Fluid[$c].temperature
    else
    end
  end
  return $acc
end

__demand(__parallel)
task CalculateMaxTemperature($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.temperature)
do
  var $acc : double = -inf
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc max= $Fluid[$c].temperature
    else
    end
  end
  return $acc
end

__demand(__parallel)
task Particles_IntegrateQuantities($particles : region(ispace(int1d), particles_columns)) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.temperature), reads($particles.__valid)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $acc += $particles[$p].temperature
    else
    end
  end
  return $acc
end

__demand(__parallel, __cuda)
task Radiation_InitializeCell($Radiation : region(ispace(int3d), Radiation_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($Radiation.G), writes($Radiation.G), reads($Radiation.I_1), writes($Radiation.I_1), reads($Radiation.I_2), writes($Radiation.I_2), reads($Radiation.I_3), writes($Radiation.I_3), reads($Radiation.I_4), writes($Radiation.I_4), reads($Radiation.I_5), writes($Radiation.I_5), reads($Radiation.I_6), writes($Radiation.I_6), reads($Radiation.I_7), writes($Radiation.I_7), reads($Radiation.I_8), writes($Radiation.I_8), reads($Radiation.Iiter_1), writes($Radiation.Iiter_1), reads($Radiation.Iiter_2), writes($Radiation.Iiter_2), reads($Radiation.Iiter_3), writes($Radiation.Iiter_3), reads($Radiation.Iiter_4), writes($Radiation.Iiter_4), reads($Radiation.Iiter_5), writes($Radiation.Iiter_5), reads($Radiation.Iiter_6), writes($Radiation.Iiter_6), reads($Radiation.Iiter_7), writes($Radiation.Iiter_7), reads($Radiation.Iiter_8), writes($Radiation.Iiter_8), reads($Radiation.S), writes($Radiation.S)
do
  __demand(__openmp)
  for $c : int3d(Radiation_columns, $Radiation) in $Radiation do
    for $m : int32 = int32(0), int32(14) do
      $Radiation[$c].I_1[$m] = double(0)
      $Radiation[$c].I_2[$m] = double(0)
      $Radiation[$c].I_3[$m] = double(0)
      $Radiation[$c].I_4[$m] = double(0)
      $Radiation[$c].I_5[$m] = double(0)
      $Radiation[$c].I_6[$m] = double(0)
      $Radiation[$c].I_7[$m] = double(0)
      $Radiation[$c].I_8[$m] = double(0)
      $Radiation[$c].Iiter_1[$m] = double(0)
      $Radiation[$c].Iiter_2[$m] = double(0)
      $Radiation[$c].Iiter_3[$m] = double(0)
      $Radiation[$c].Iiter_4[$m] = double(0)
      $Radiation[$c].Iiter_5[$m] = double(0)
      $Radiation[$c].Iiter_6[$m] = double(0)
      $Radiation[$c].Iiter_7[$m] = double(0)
      $Radiation[$c].Iiter_8[$m] = double(0)
    end
    $Radiation[$c].G = double(0)
    $Radiation[$c].S = double(0)
  end
end

Fluid_dump_rho_pressure_velocity = HDF.mkDump(int3d, int3d, Fluid_columns, {"rho","pressure","velocity"})
particles_dump_cell_position_velocity_temperature_diameter___valid = HDF.mkDump(int1d, int3d, particles_columns, {"cell","position","velocity","temperature","diameter","__valid"})
__demand(__inline)
task GetSoundSpeed($temperature : double, $Flow_gamma : double, $Flow_gasConstant : double) : double
-- leaf (false), inner (false), idempotent (false)
  return [regentlib.sqrt(double)]((($Flow_gamma*$Flow_gasConstant)*$temperature))
end

__demand(__parallel)
task CalculateConvectiveSpectralRadius($Fluid : region(ispace(int3d), Fluid_columns), $Flow_gamma : double, $Flow_gasConstant : double, $Grid_dXYZInverseSquare : double, $Grid_xCellWidth : double, $Grid_yCellWidth : double, $Grid_zCellWidth : double) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.convectiveSpectralRadius), writes($Fluid.convectiveSpectralRadius), reads($Fluid.temperature), reads($Fluid.velocity)
do
  var $acc : double = -inf
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    $Fluid[$c].convectiveSpectralRadius = (((([regentlib.fabs(double)]($Fluid[$c].velocity[int32(0)])/$Grid_xCellWidth)+([regentlib.fabs(double)]($Fluid[$c].velocity[int32(1)])/$Grid_yCellWidth))+([regentlib.fabs(double)]($Fluid[$c].velocity[int32(2)])/$Grid_zCellWidth))+(GetSoundSpeed($Fluid[$c].temperature, $Flow_gamma, $Flow_gasConstant)*[regentlib.sqrt(double)]($Grid_dXYZInverseSquare)))
    $acc max= $Fluid[$c].convectiveSpectralRadius
  end
  return $acc
end

__demand(__inline)
task GetDynamicViscosity($temperature : double, $Flow_constantVisc : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32) : double
-- leaf (false), inner (false), idempotent (false)
  var $viscosity : double = double(double(0))
  if ($Flow_viscosityModel___value==int32(0)) then
    $viscosity = $Flow_constantVisc
  else
    if ($Flow_viscosityModel___value==int32(1)) then
      $viscosity = ($Flow_powerlawViscRef*pow(($temperature/$Flow_powerlawTempRef), double(0.75)))
    else
      $viscosity = (($Flow_sutherlandViscRef*pow(($temperature/$Flow_sutherlandTempRef), (double(3)/double(2))))*(($Flow_sutherlandTempRef+$Flow_sutherlandSRef)/($temperature+$Flow_sutherlandSRef)))
    end
  end
  return $viscosity
end

__demand(__parallel)
task CalculateViscousSpectralRadius($Fluid : region(ispace(int3d), Fluid_columns), $Flow_constantVisc : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32, $Grid_dXYZInverseSquare : double) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rho), reads($Fluid.sgsEddyViscosity), reads($Fluid.temperature), reads($Fluid.viscousSpectralRadius), writes($Fluid.viscousSpectralRadius)
do
  var $acc : double = -inf
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    var $dynamicViscosity : double = GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)
    var $eddyViscosity : double = $Fluid[$c].sgsEddyViscosity
    $Fluid[$c].viscousSpectralRadius = ((((double(2)*($dynamicViscosity+$eddyViscosity))/$Fluid[$c].rho)*$Grid_dXYZInverseSquare)*double(4))
    $acc max= $Fluid[$c].viscousSpectralRadius
  end
  return $acc
end

__demand(__parallel)
task CalculateHeatConductionSpectralRadius($Fluid : region(ispace(int3d), Fluid_columns), $Flow_constantVisc : double, $Flow_gamma : double, $Flow_gasConstant : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_prandtl : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32, $Grid_dXYZInverseSquare : double) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.heatConductionSpectralRadius), writes($Fluid.heatConductionSpectralRadius), reads($Fluid.rho), reads($Fluid.sgsEddyKappa), reads($Fluid.temperature)
do
  var $acc : double = -inf
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    var $dynamicViscosity : double = GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)
    var $cv : double = ($Flow_gasConstant/($Flow_gamma-double(1)))
    var $cp : double = ($Flow_gamma*$cv)
    var $kappa : double = (($cp/$Flow_prandtl)*$dynamicViscosity)
    $Fluid[$c].heatConductionSpectralRadius = (((($kappa+$Fluid[$c].sgsEddyKappa)/($cv*$Fluid[$c].rho))*$Grid_dXYZInverseSquare)*double(4))
    $acc max= $Fluid[$c].heatConductionSpectralRadius
  end
  return $acc
end

__demand(__parallel, __cuda)
task Flow_InitializeTemporaries($Fluid : region(ispace(int3d), Fluid_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rho), reads($Fluid.rhoEnergy), reads($Fluid.rhoEnergy_new), writes($Fluid.rhoEnergy_new), reads($Fluid.rhoEnergy_old), writes($Fluid.rhoEnergy_old), reads($Fluid.rhoVelocity), reads($Fluid.rhoVelocity_new), writes($Fluid.rhoVelocity_new), reads($Fluid.rhoVelocity_old), writes($Fluid.rhoVelocity_old), reads($Fluid.rho_new), writes($Fluid.rho_new), reads($Fluid.rho_old), writes($Fluid.rho_old)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    $Fluid[$c].rho_old = $Fluid[$c].rho
    $Fluid[$c].rhoVelocity_old = $Fluid[$c].rhoVelocity
    $Fluid[$c].rhoEnergy_old = $Fluid[$c].rhoEnergy
    $Fluid[$c].rho_new = $Fluid[$c].rho
    $Fluid[$c].rhoVelocity_new = $Fluid[$c].rhoVelocity
    $Fluid[$c].rhoEnergy_new = $Fluid[$c].rhoEnergy
  end
end

__demand(__parallel, __cuda)
task Particles_InitializeTemporaries($particles : region(ispace(int1d), particles_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.position), reads($particles.position_new), writes($particles.position_new), reads($particles.position_old), writes($particles.position_old), reads($particles.temperature), reads($particles.temperature_new), writes($particles.temperature_new), reads($particles.temperature_old), writes($particles.temperature_old), reads($particles.velocity), reads($particles.velocity_new), writes($particles.velocity_new), reads($particles.velocity_old), writes($particles.velocity_old), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $particles[$p].position_old = $particles[$p].position
      $particles[$p].velocity_old = $particles[$p].velocity
      $particles[$p].temperature_old = $particles[$p].temperature
      $particles[$p].position_new = $particles[$p].position
      $particles[$p].velocity_new = $particles[$p].velocity
      $particles[$p].temperature_new = $particles[$p].temperature
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_InitializeTimeDerivatives($Fluid : region(ispace(int3d), Fluid_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.rhoEnergy), reads($Fluid.rhoEnergy_t), writes($Fluid.rhoEnergy_t), reads($Fluid.rhoEnthalpy), writes($Fluid.rhoEnthalpy), reads($Fluid.rhoVelocity_t), writes($Fluid.rhoVelocity_t), reads($Fluid.rho_t), writes($Fluid.rho_t)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    $Fluid[$c].rho_t = double(double(0))
    $Fluid[$c].rhoVelocity_t = double[3](array(double(0), double(0), double(0)))
    $Fluid[$c].rhoEnergy_t = double(double(0))
    $Fluid[$c].rhoEnthalpy = ($Fluid[$c].rhoEnergy+$Fluid[$c].pressure)
  end
end

__demand(__parallel, __cuda)
task Particles_InitializeTimeDerivatives($particles : region(ispace(int1d), particles_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.position_t), writes($particles.position_t), reads($particles.temperature_t), writes($particles.temperature_t), reads($particles.velocity_t), writes($particles.velocity_t), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $particles[$p].position_t = double[3](array(double(0), double(0), double(0)))
      $particles[$p].velocity_t = double[3](array(double(0), double(0), double(0)))
      $particles[$p].temperature_t = double(int32(0))
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostVelocityGradientStep1($Fluid : region(ispace(int3d), Fluid_columns), $BC_xSign : double[3], $BC_ySign : double[3], $BC_zSign : double[3], $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.velocityGradientX), reads($Fluid.velocityGradientXBoundary), writes($Fluid.velocityGradientXBoundary), reads($Fluid.velocityGradientY), reads($Fluid.velocityGradientYBoundary), writes($Fluid.velocityGradientYBoundary), reads($Fluid.velocityGradientZ), reads($Fluid.velocityGradientZBoundary), writes($Fluid.velocityGradientZBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      $Fluid[$c_bnd].velocityGradientXBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientX)
      $Fluid[$c_bnd].velocityGradientYBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientY)
      $Fluid[$c_bnd].velocityGradientZBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientZ)
    else
    end
    if (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{-1, 0, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_xSign
      $Fluid[$c_bnd].velocityGradientXBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientX)
      $Fluid[$c_bnd].velocityGradientYBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientY)
      $Fluid[$c_bnd].velocityGradientZBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientZ)
    else
    end
    if (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      $Fluid[$c_bnd].velocityGradientXBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientX)
      $Fluid[$c_bnd].velocityGradientYBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientY)
      $Fluid[$c_bnd].velocityGradientZBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientZ)
    else
    end
    if (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, -1, 0})%$Fluid.bounds)
      var $sign : double[3] = $BC_ySign
      $Fluid[$c_bnd].velocityGradientXBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientX)
      $Fluid[$c_bnd].velocityGradientYBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientY)
      $Fluid[$c_bnd].velocityGradientZBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientZ)
    else
    end
    if (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, 1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      $Fluid[$c_bnd].velocityGradientXBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientX)
      $Fluid[$c_bnd].velocityGradientYBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientY)
      $Fluid[$c_bnd].velocityGradientZBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientZ)
    else
    end
    if (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)) then
      var $c_bnd : int3d = int3d($c)
      var $c_int : int3d = (($c+{0, 0, -1})%$Fluid.bounds)
      var $sign : double[3] = $BC_zSign
      $Fluid[$c_bnd].velocityGradientXBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientX)
      $Fluid[$c_bnd].velocityGradientYBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientY)
      $Fluid[$c_bnd].velocityGradientZBoundary = vv_mul_double_3($sign, $Fluid[$c_int].velocityGradientZ)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateGhostVelocityGradientStep2($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.velocityGradientX), writes($Fluid.velocityGradientX), reads($Fluid.velocityGradientXBoundary), reads($Fluid.velocityGradientY), writes($Fluid.velocityGradientY), reads($Fluid.velocityGradientYBoundary), reads($Fluid.velocityGradientZ), writes($Fluid.velocityGradientZ), reads($Fluid.velocityGradientZBoundary)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0))) then
      $Fluid[$c].velocityGradientX = $Fluid[$c].velocityGradientXBoundary
      $Fluid[$c].velocityGradientY = $Fluid[$c].velocityGradientYBoundary
      $Fluid[$c].velocityGradientZ = $Fluid[$c].velocityGradientZBoundary
    else
    end
  end
end

__demand(__inline)
task CenteredInviscidFlux($c_l : int3d, $c_r : int3d, $Fluid : region(ispace(int3d), Fluid_columns)) : double[5]
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.rho), reads($Fluid.rhoEnthalpy), reads($Fluid.rhoVelocity), reads($Fluid.velocity)
do
  var $rhoFactorDiagonal : double = double(double(0))
  var $rhoVelocityFactorDiagonal : double[3] = double[3](array(double(0), double(0), double(0)))
  var $rhoEnergyFactorDiagonal : double = double(double(0))
  var $fpdiag : double = double(double(0))
  $rhoFactorDiagonal = (double(0.5)*(($Fluid[$c_l].rho*$Fluid[$c_l].velocity[int32(0)])+($Fluid[$c_r].rho*$Fluid[$c_r].velocity[int32(0)])))
  $rhoVelocityFactorDiagonal = vs_mul_double_3(vv_add_double_3(vs_mul_double_3($Fluid[$c_l].rhoVelocity, $Fluid[$c_l].velocity[int32(0)]), vs_mul_double_3($Fluid[$c_r].rhoVelocity, $Fluid[$c_r].velocity[int32(0)])), double(0.5))
  $rhoEnergyFactorDiagonal = (double(0.5)*(($Fluid[$c_l].rhoEnthalpy*$Fluid[$c_l].velocity[int32(0)])+($Fluid[$c_r].rhoEnthalpy*$Fluid[$c_r].velocity[int32(0)])))
  $fpdiag += (double(0.5)*($Fluid[$c_l].pressure+$Fluid[$c_r].pressure))
  var $rhoFactorSkew : double = double(double(0))
  var $rhoVelocityFactorSkew : double[3] = double[3](array(double(0), double(0), double(0)))
  var $rhoEnergyFactorSkew : double = double(double(0))
  var $tmp : double = double(double(0))
  $tmp = (double(0.5)*$Fluid[$c_r].velocity[int32(0)])
  $rhoFactorSkew += ($Fluid[$c_l].rho*$tmp)
  var $tmp#6137 : double[3] = vs_mul_double_3($Fluid[$c_l].rhoVelocity, $tmp)
  var $v : double[3] = $rhoVelocityFactorSkew
  $v[0] += $tmp#6137[0]
  $v[1] += $tmp#6137[1]
  $v[2] += $tmp#6137[2]
  $rhoVelocityFactorSkew = $v
  $rhoEnergyFactorSkew += ($Fluid[$c_l].rhoEnthalpy*$tmp)
  $tmp = (double(0.5)*$Fluid[$c_l].velocity[int32(0)])
  $rhoFactorSkew += ($Fluid[$c_r].rho*$tmp)
  var $tmp#6139 : double[3] = vs_mul_double_3($Fluid[$c_r].rhoVelocity, $tmp)
  var $v#6140 : double[3] = $rhoVelocityFactorSkew
  $v#6140[0] += $tmp#6139[0]
  $v#6140[1] += $tmp#6139[1]
  $v#6140[2] += $tmp#6139[2]
  $rhoVelocityFactorSkew = $v#6140
  $rhoEnergyFactorSkew += ($Fluid[$c_r].rhoEnthalpy*$tmp)
  var $s : double = double(0.5)
  var $rhoFlux_temp : double = (($s*$rhoFactorDiagonal)+((double(int32(1))-$s)*$rhoFactorSkew))
  var $rhoVelocityFlux_temp : double[3] = vv_add_double_3(vs_mul_double_3($rhoVelocityFactorDiagonal, $s), vs_mul_double_3($rhoVelocityFactorSkew, (double(int32(1))-$s)))
  var $rhoEnergyFlux_temp : double = (($s*$rhoEnergyFactorDiagonal)+((double(int32(1))-$s)*$rhoEnergyFactorSkew))
  $rhoVelocityFlux_temp[int32(0)] += $fpdiag
  return array($rhoFlux_temp, $rhoVelocityFlux_temp[int32(0)], $rhoVelocityFlux_temp[int32(1)], $rhoVelocityFlux_temp[int32(2)], $rhoEnergyFlux_temp)
end

__demand(__inline)
task CenteredInviscidFlux_($c_l : int3d, $c_r : int3d, $Fluid : region(ispace(int3d), Fluid_columns)) : double[5]
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.rho), reads($Fluid.rhoEnthalpy), reads($Fluid.rhoVelocity), reads($Fluid.velocity)
do
  var $rhoFactorDiagonal : double = double(double(0))
  var $rhoVelocityFactorDiagonal : double[3] = double[3](array(double(0), double(0), double(0)))
  var $rhoEnergyFactorDiagonal : double = double(double(0))
  var $fpdiag : double = double(double(0))
  $rhoFactorDiagonal = (double(0.5)*(($Fluid[$c_l].rho*$Fluid[$c_l].velocity[int32(1)])+($Fluid[$c_r].rho*$Fluid[$c_r].velocity[int32(1)])))
  $rhoVelocityFactorDiagonal = vs_mul_double_3(vv_add_double_3(vs_mul_double_3($Fluid[$c_l].rhoVelocity, $Fluid[$c_l].velocity[int32(1)]), vs_mul_double_3($Fluid[$c_r].rhoVelocity, $Fluid[$c_r].velocity[int32(1)])), double(0.5))
  $rhoEnergyFactorDiagonal = (double(0.5)*(($Fluid[$c_l].rhoEnthalpy*$Fluid[$c_l].velocity[int32(1)])+($Fluid[$c_r].rhoEnthalpy*$Fluid[$c_r].velocity[int32(1)])))
  $fpdiag += (double(0.5)*($Fluid[$c_l].pressure+$Fluid[$c_r].pressure))
  var $rhoFactorSkew : double = double(double(0))
  var $rhoVelocityFactorSkew : double[3] = double[3](array(double(0), double(0), double(0)))
  var $rhoEnergyFactorSkew : double = double(double(0))
  var $tmp : double = double(double(0))
  $tmp = (double(0.5)*$Fluid[$c_r].velocity[int32(1)])
  $rhoFactorSkew += ($Fluid[$c_l].rho*$tmp)
  var $tmp#6344 : double[3] = vs_mul_double_3($Fluid[$c_l].rhoVelocity, $tmp)
  var $v : double[3] = $rhoVelocityFactorSkew
  $v[0] += $tmp#6344[0]
  $v[1] += $tmp#6344[1]
  $v[2] += $tmp#6344[2]
  $rhoVelocityFactorSkew = $v
  $rhoEnergyFactorSkew += ($Fluid[$c_l].rhoEnthalpy*$tmp)
  $tmp = (double(0.5)*$Fluid[$c_l].velocity[int32(1)])
  $rhoFactorSkew += ($Fluid[$c_r].rho*$tmp)
  var $tmp#6346 : double[3] = vs_mul_double_3($Fluid[$c_r].rhoVelocity, $tmp)
  var $v#6347 : double[3] = $rhoVelocityFactorSkew
  $v#6347[0] += $tmp#6346[0]
  $v#6347[1] += $tmp#6346[1]
  $v#6347[2] += $tmp#6346[2]
  $rhoVelocityFactorSkew = $v#6347
  $rhoEnergyFactorSkew += ($Fluid[$c_r].rhoEnthalpy*$tmp)
  var $s : double = double(0.5)
  var $rhoFlux_temp : double = (($s*$rhoFactorDiagonal)+((double(int32(1))-$s)*$rhoFactorSkew))
  var $rhoVelocityFlux_temp : double[3] = vv_add_double_3(vs_mul_double_3($rhoVelocityFactorDiagonal, $s), vs_mul_double_3($rhoVelocityFactorSkew, (double(int32(1))-$s)))
  var $rhoEnergyFlux_temp : double = (($s*$rhoEnergyFactorDiagonal)+((double(int32(1))-$s)*$rhoEnergyFactorSkew))
  $rhoVelocityFlux_temp[int32(1)] += $fpdiag
  return array($rhoFlux_temp, $rhoVelocityFlux_temp[int32(0)], $rhoVelocityFlux_temp[int32(1)], $rhoVelocityFlux_temp[int32(2)], $rhoEnergyFlux_temp)
end

__demand(__inline)
task CenteredInviscidFlux__($c_l : int3d, $c_r : int3d, $Fluid : region(ispace(int3d), Fluid_columns)) : double[5]
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.rho), reads($Fluid.rhoEnthalpy), reads($Fluid.rhoVelocity), reads($Fluid.velocity)
do
  var $rhoFactorDiagonal : double = double(double(0))
  var $rhoVelocityFactorDiagonal : double[3] = double[3](array(double(0), double(0), double(0)))
  var $rhoEnergyFactorDiagonal : double = double(double(0))
  var $fpdiag : double = double(double(0))
  $rhoFactorDiagonal = (double(0.5)*(($Fluid[$c_l].rho*$Fluid[$c_l].velocity[int32(2)])+($Fluid[$c_r].rho*$Fluid[$c_r].velocity[int32(2)])))
  $rhoVelocityFactorDiagonal = vs_mul_double_3(vv_add_double_3(vs_mul_double_3($Fluid[$c_l].rhoVelocity, $Fluid[$c_l].velocity[int32(2)]), vs_mul_double_3($Fluid[$c_r].rhoVelocity, $Fluid[$c_r].velocity[int32(2)])), double(0.5))
  $rhoEnergyFactorDiagonal = (double(0.5)*(($Fluid[$c_l].rhoEnthalpy*$Fluid[$c_l].velocity[int32(2)])+($Fluid[$c_r].rhoEnthalpy*$Fluid[$c_r].velocity[int32(2)])))
  $fpdiag += (double(0.5)*($Fluid[$c_l].pressure+$Fluid[$c_r].pressure))
  var $rhoFactorSkew : double = double(double(0))
  var $rhoVelocityFactorSkew : double[3] = double[3](array(double(0), double(0), double(0)))
  var $rhoEnergyFactorSkew : double = double(double(0))
  var $tmp : double = double(double(0))
  $tmp = (double(0.5)*$Fluid[$c_r].velocity[int32(2)])
  $rhoFactorSkew += ($Fluid[$c_l].rho*$tmp)
  var $tmp#6551 : double[3] = vs_mul_double_3($Fluid[$c_l].rhoVelocity, $tmp)
  var $v : double[3] = $rhoVelocityFactorSkew
  $v[0] += $tmp#6551[0]
  $v[1] += $tmp#6551[1]
  $v[2] += $tmp#6551[2]
  $rhoVelocityFactorSkew = $v
  $rhoEnergyFactorSkew += ($Fluid[$c_l].rhoEnthalpy*$tmp)
  $tmp = (double(0.5)*$Fluid[$c_l].velocity[int32(2)])
  $rhoFactorSkew += ($Fluid[$c_r].rho*$tmp)
  var $tmp#6553 : double[3] = vs_mul_double_3($Fluid[$c_r].rhoVelocity, $tmp)
  var $v#6554 : double[3] = $rhoVelocityFactorSkew
  $v#6554[0] += $tmp#6553[0]
  $v#6554[1] += $tmp#6553[1]
  $v#6554[2] += $tmp#6553[2]
  $rhoVelocityFactorSkew = $v#6554
  $rhoEnergyFactorSkew += ($Fluid[$c_r].rhoEnthalpy*$tmp)
  var $s : double = double(0.5)
  var $rhoFlux_temp : double = (($s*$rhoFactorDiagonal)+((double(int32(1))-$s)*$rhoFactorSkew))
  var $rhoVelocityFlux_temp : double[3] = vv_add_double_3(vs_mul_double_3($rhoVelocityFactorDiagonal, $s), vs_mul_double_3($rhoVelocityFactorSkew, (double(int32(1))-$s)))
  var $rhoEnergyFlux_temp : double = (($s*$rhoEnergyFactorDiagonal)+((double(int32(1))-$s)*$rhoEnergyFactorSkew))
  $rhoVelocityFlux_temp[int32(2)] += $fpdiag
  return array($rhoFlux_temp, $rhoVelocityFlux_temp[int32(0)], $rhoVelocityFlux_temp[int32(1)], $rhoVelocityFlux_temp[int32(2)], $rhoEnergyFlux_temp)
end

__demand(__parallel, __cuda)
task Flow_AddGetFlux($Fluid : region(ispace(int3d), Fluid_columns), $Flow_constantVisc : double, $Flow_gamma : double, $Flow_gasConstant : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_prandtl : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32, $Grid_xBnum : int32, $Grid_xCellWidth : double, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yCellWidth : double, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zCellWidth : double, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.pressure), reads($Fluid.rho), reads($Fluid.rhoEnergyFluxX), writes($Fluid.rhoEnergyFluxX), reads($Fluid.rhoEnergyFluxX), writes($Fluid.rhoEnergyFluxX), reads($Fluid.rhoEnergyFluxY), writes($Fluid.rhoEnergyFluxY), reads($Fluid.rhoEnergyFluxY), writes($Fluid.rhoEnergyFluxY), reads($Fluid.rhoEnergyFluxZ), writes($Fluid.rhoEnergyFluxZ), reads($Fluid.rhoEnergyFluxZ), writes($Fluid.rhoEnergyFluxZ), reads($Fluid.rhoEnthalpy), reads($Fluid.rhoFluxX), writes($Fluid.rhoFluxX), reads($Fluid.rhoFluxY), writes($Fluid.rhoFluxY), reads($Fluid.rhoFluxZ), writes($Fluid.rhoFluxZ), reads($Fluid.rhoVelocity), reads($Fluid.rhoVelocityFluxX), writes($Fluid.rhoVelocityFluxX), reads($Fluid.rhoVelocityFluxX), writes($Fluid.rhoVelocityFluxX), reads($Fluid.rhoVelocityFluxY), writes($Fluid.rhoVelocityFluxY), reads($Fluid.rhoVelocityFluxY), writes($Fluid.rhoVelocityFluxY), reads($Fluid.rhoVelocityFluxZ), writes($Fluid.rhoVelocityFluxZ), reads($Fluid.rhoVelocityFluxZ), writes($Fluid.rhoVelocityFluxZ), reads($Fluid.temperature), reads($Fluid.velocity), reads($Fluid.velocityGradientX), reads($Fluid.velocityGradientY), reads($Fluid.velocityGradientZ)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) or (max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))==int32(1))) then
      var $flux : double[5] = CenteredInviscidFlux(int3d($c), (($c+{1, 0, 0})%$Fluid.bounds), $Fluid)
      $Fluid[$c].rhoFluxX = $flux[int32(0)]
      $Fluid[$c].rhoVelocityFluxX = array($flux[int32(1)], $flux[int32(2)], $flux[int32(3)])
      $Fluid[$c].rhoEnergyFluxX = $flux[int32(4)]
      var $muFace : double = (double(0.5)*(GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)+GetDynamicViscosity($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)))
      var $velocityFace : double[3] = double[3](array(double(0), double(0), double(0)))
      var $velocityX_YFace : double = double(double(0))
      var $velocityX_ZFace : double = double(double(0))
      var $velocityY_YFace : double = double(double(0))
      var $velocityZ_ZFace : double = double(double(0))
      $velocityFace = vs_mul_double_3(vv_add_double_3($Fluid[$c].velocity, $Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity), double(0.5))
      $velocityX_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(0)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientY[int32(0)]))
      $velocityX_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(0)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientZ[int32(0)]))
      $velocityY_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(1)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientY[int32(1)]))
      $velocityZ_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(2)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientZ[int32(2)]))
      var $velocityX_XFace : double = double(double(0))
      var $velocityY_XFace : double = double(double(0))
      var $velocityZ_XFace : double = double(double(0))
      var $temperature_XFace : double = double(double(0))
      $velocityX_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity[int32(0)]-$Fluid[$c].velocity[int32(0)]))
      $velocityY_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity[int32(1)]-$Fluid[$c].velocity[int32(1)]))
      $velocityZ_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity[int32(2)]-$Fluid[$c].velocity[int32(2)]))
      $temperature_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].temperature-$Fluid[$c].temperature))
      $velocityX_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      $velocityY_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      $velocityZ_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      $temperature_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      var $sigmaXX : double = (($muFace*(((double(4)*$velocityX_XFace)-(double(2)*$velocityY_YFace))-(double(2)*$velocityZ_ZFace)))/double(3))
      var $sigmaYX : double = ($muFace*($velocityY_XFace+$velocityX_YFace))
      var $sigmaZX : double = ($muFace*($velocityZ_XFace+$velocityX_ZFace))
      var $usigma : double = ((($velocityFace[int32(0)]*$sigmaXX)+($velocityFace[int32(1)]*$sigmaYX))+($velocityFace[int32(2)]*$sigmaZX))
      var $cp : double = (($Flow_gamma*$Flow_gasConstant)/($Flow_gamma-double(1)))
      var $heatFlux : double = ((-(($cp*$muFace)/$Flow_prandtl))*$temperature_XFace)
      $Fluid[$c].rhoVelocityFluxX[int32(0)] += (-$sigmaXX)
      $Fluid[$c].rhoVelocityFluxX[int32(1)] += (-$sigmaYX)
      $Fluid[$c].rhoVelocityFluxX[int32(2)] += (-$sigmaZX)
      $Fluid[$c].rhoEnergyFluxX += (-($usigma-$heatFlux))
    else
    end
    if ((not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))==int32(1))) then
      var $flux : double[5] = CenteredInviscidFlux_(int3d($c), (($c+{0, 1, 0})%$Fluid.bounds), $Fluid)
      $Fluid[$c].rhoFluxY = $flux[int32(0)]
      $Fluid[$c].rhoVelocityFluxY = array($flux[int32(1)], $flux[int32(2)], $flux[int32(3)])
      $Fluid[$c].rhoEnergyFluxY = $flux[int32(4)]
      var $muFace : double = (double(0.5)*(GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)+GetDynamicViscosity($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)))
      var $velocityFace : double[3] = double[3](array(double(0), double(0), double(0)))
      var $velocityY_XFace : double = double(double(0))
      var $velocityY_ZFace : double = double(double(0))
      var $velocityX_XFace : double = double(double(0))
      var $velocityZ_ZFace : double = double(double(0))
      $velocityFace = vs_mul_double_3(vv_add_double_3($Fluid[$c].velocity, $Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity), double(0.5))
      $velocityY_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(1)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientX[int32(1)]))
      $velocityY_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(1)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientZ[int32(1)]))
      $velocityX_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(0)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientX[int32(0)]))
      $velocityZ_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(2)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientZ[int32(2)]))
      var $velocityX_YFace : double = double(double(0))
      var $velocityY_YFace : double = double(double(0))
      var $velocityZ_YFace : double = double(double(0))
      var $temperature_YFace : double = double(double(0))
      $velocityX_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity[int32(0)]-$Fluid[$c].velocity[int32(0)]))
      $velocityY_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity[int32(1)]-$Fluid[$c].velocity[int32(1)]))
      $velocityZ_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity[int32(2)]-$Fluid[$c].velocity[int32(2)]))
      $temperature_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].temperature-$Fluid[$c].temperature))
      $velocityX_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      $velocityY_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      $velocityZ_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      $temperature_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      var $sigmaXY : double = ($muFace*($velocityX_YFace+$velocityY_XFace))
      var $sigmaYY : double = (($muFace*(((double(4)*$velocityY_YFace)-(double(2)*$velocityX_XFace))-(double(2)*$velocityZ_ZFace)))/double(3))
      var $sigmaZY : double = ($muFace*($velocityZ_YFace+$velocityY_ZFace))
      var $usigma : double = ((($velocityFace[int32(0)]*$sigmaXY)+($velocityFace[int32(1)]*$sigmaYY))+($velocityFace[int32(2)]*$sigmaZY))
      var $cp : double = (($Flow_gamma*$Flow_gasConstant)/($Flow_gamma-double(1)))
      var $heatFlux : double = ((-(($cp*$muFace)/$Flow_prandtl))*$temperature_YFace)
      $Fluid[$c].rhoVelocityFluxY[int32(0)] += (-$sigmaXY)
      $Fluid[$c].rhoVelocityFluxY[int32(1)] += (-$sigmaYY)
      $Fluid[$c].rhoVelocityFluxY[int32(2)] += (-$sigmaZY)
      $Fluid[$c].rhoEnergyFluxY += (-($usigma-$heatFlux))
    else
    end
    if ((not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))==int32(1))) then
      var $flux : double[5] = CenteredInviscidFlux__(int3d($c), (($c+{0, 0, 1})%$Fluid.bounds), $Fluid)
      $Fluid[$c].rhoFluxZ = $flux[int32(0)]
      $Fluid[$c].rhoVelocityFluxZ = array($flux[int32(1)], $flux[int32(2)], $flux[int32(3)])
      $Fluid[$c].rhoEnergyFluxZ = $flux[int32(4)]
      var $muFace : double = (double(0.5)*(GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)+GetDynamicViscosity($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)))
      var $velocityFace : double[3] = double[3](array(double(0), double(0), double(0)))
      var $velocityZ_XFace : double = double(double(0))
      var $velocityZ_YFace : double = double(double(0))
      var $velocityX_XFace : double = double(double(0))
      var $velocityY_YFace : double = double(double(0))
      $velocityFace = vs_mul_double_3(vv_add_double_3($Fluid[$c].velocity, $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity), double(0.5))
      $velocityZ_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(2)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientX[int32(2)]))
      $velocityZ_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(2)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientY[int32(2)]))
      $velocityX_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(0)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientX[int32(0)]))
      $velocityY_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(1)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientY[int32(1)]))
      var $velocityX_ZFace : double = double(double(0))
      var $velocityY_ZFace : double = double(double(0))
      var $velocityZ_ZFace : double = double(double(0))
      var $temperature_ZFace : double = double(double(0))
      $velocityX_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity[int32(0)]-$Fluid[$c].velocity[int32(0)]))
      $velocityY_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity[int32(1)]-$Fluid[$c].velocity[int32(1)]))
      $velocityZ_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity[int32(2)]-$Fluid[$c].velocity[int32(2)]))
      $temperature_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature-$Fluid[$c].temperature))
      $velocityX_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      $velocityY_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      $velocityZ_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      $temperature_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      var $sigmaXZ : double = ($muFace*($velocityX_ZFace+$velocityZ_XFace))
      var $sigmaYZ : double = ($muFace*($velocityY_ZFace+$velocityZ_YFace))
      var $sigmaZZ : double = (($muFace*(((double(4)*$velocityZ_ZFace)-(double(2)*$velocityX_XFace))-(double(2)*$velocityY_YFace)))/double(3))
      var $usigma : double = ((($velocityFace[int32(0)]*$sigmaXZ)+($velocityFace[int32(1)]*$sigmaYZ))+($velocityFace[int32(2)]*$sigmaZZ))
      var $cp : double = (($Flow_gamma*$Flow_gasConstant)/($Flow_gamma-double(1)))
      var $heatFlux : double = ((-(($cp*$muFace)/$Flow_prandtl))*$temperature_ZFace)
      $Fluid[$c].rhoVelocityFluxZ[int32(0)] += (-$sigmaXZ)
      $Fluid[$c].rhoVelocityFluxZ[int32(1)] += (-$sigmaYZ)
      $Fluid[$c].rhoVelocityFluxZ[int32(2)] += (-$sigmaZZ)
      $Fluid[$c].rhoEnergyFluxZ += (-($usigma-$heatFlux))
    else
    end
    var $v : int32 = int32(0)
    if ($v==int32(1)) then
      var $tmp1 : double = $Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].velocity[int32(0)]
      var $tmp2 : double = $Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].velocity[int32(1)]
      var $tmp3 : double = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].velocity[int32(2)]
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_AddUpdateUsingFlux($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xCellWidth : double, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yCellWidth : double, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zCellWidth : double, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rhoEnergyFluxX), reads($Fluid.rhoEnergyFluxY), reads($Fluid.rhoEnergyFluxZ), reads($Fluid.rhoEnergy_t), writes($Fluid.rhoEnergy_t), reads($Fluid.rhoFluxX), reads($Fluid.rhoFluxY), reads($Fluid.rhoFluxZ), reads($Fluid.rhoVelocityFluxX), reads($Fluid.rhoVelocityFluxY), reads($Fluid.rhoVelocityFluxZ), reads($Fluid.rhoVelocity_t), writes($Fluid.rhoVelocity_t), reads($Fluid.rho_t), writes($Fluid.rho_t)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $Fluid[$c].rho_t += ((-($Fluid[$c].rhoFluxX-$Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].rhoFluxX))/$Grid_xCellWidth)
      var $tmp : double[3] = vs_div_double_3(vs_mul_double_3(vv_sub_double_3($Fluid[$c].rhoVelocityFluxX, $Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].rhoVelocityFluxX), double((-1))), $Grid_xCellWidth)
      var $v : double[3] = $Fluid[$c].rhoVelocity_t
      $v[0] += $tmp[0]
      $v[1] += $tmp[1]
      $v[2] += $tmp[2]
      $Fluid[$c].rhoVelocity_t = $v
      $Fluid[$c].rhoEnergy_t += ((-($Fluid[$c].rhoEnergyFluxX-$Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].rhoEnergyFluxX))/$Grid_xCellWidth)
      $Fluid[$c].rho_t += ((-($Fluid[$c].rhoFluxY-$Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].rhoFluxY))/$Grid_yCellWidth)
      var $tmp#7144 : double[3] = vs_div_double_3(vs_mul_double_3(vv_sub_double_3($Fluid[$c].rhoVelocityFluxY, $Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].rhoVelocityFluxY), double((-1))), $Grid_yCellWidth)
      var $v#7145 : double[3] = $Fluid[$c].rhoVelocity_t
      $v#7145[0] += $tmp#7144[0]
      $v#7145[1] += $tmp#7144[1]
      $v#7145[2] += $tmp#7144[2]
      $Fluid[$c].rhoVelocity_t = $v#7145
      $Fluid[$c].rhoEnergy_t += ((-($Fluid[$c].rhoEnergyFluxY-$Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].rhoEnergyFluxY))/$Grid_yCellWidth)
      $Fluid[$c].rho_t += ((-($Fluid[$c].rhoFluxZ-$Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].rhoFluxZ))/$Grid_zCellWidth)
      var $tmp#7146 : double[3] = vs_div_double_3(vs_mul_double_3(vv_sub_double_3($Fluid[$c].rhoVelocityFluxZ, $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].rhoVelocityFluxZ), double((-1))), $Grid_zCellWidth)
      var $v#7147 : double[3] = $Fluid[$c].rhoVelocity_t
      $v#7147[0] += $tmp#7146[0]
      $v#7147[1] += $tmp#7146[1]
      $v#7147[2] += $tmp#7146[2]
      $Fluid[$c].rhoVelocity_t = $v#7147
      $Fluid[$c].rhoEnergy_t += ((-($Fluid[$c].rhoEnergyFluxZ-$Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].rhoEnergyFluxZ))/$Grid_zCellWidth)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_AddBodyForces($Fluid : region(ispace(int3d), Fluid_columns), $Flow_bodyForce : double[3], $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rho), reads($Fluid.rhoEnergy_t), writes($Fluid.rhoEnergy_t), reads($Fluid.rhoVelocity_t), writes($Fluid.rhoVelocity_t), reads($Fluid.velocity)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      var $tmp : double[3] = vs_mul_double_3($Flow_bodyForce, $Fluid[$c].rho)
      var $v : double[3] = $Fluid[$c].rhoVelocity_t
      $v[0] += $tmp[0]
      $v[1] += $tmp[1]
      $v[2] += $tmp[2]
      $Fluid[$c].rhoVelocity_t = $v
      $Fluid[$c].rhoEnergy_t += ($Fluid[$c].rho*dot_double_3($Flow_bodyForce, $Fluid[$c].velocity))
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdatePD($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.PD), writes($Fluid.PD), reads($Fluid.pressure), reads($Fluid.velocityGradientX), reads($Fluid.velocityGradientY), reads($Fluid.velocityGradientZ)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      var $divU : double = double(double(0))
      $divU = (($Fluid[$c].velocityGradientX[int32(0)]+$Fluid[$c].velocityGradientY[int32(1)])+$Fluid[$c].velocityGradientZ[int32(2)])
      $Fluid[$c].PD = ($divU*$Fluid[$c].pressure)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_ResetDissipation($Fluid : region(ispace(int3d), Fluid_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipation), writes($Fluid.dissipation)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    $Fluid[$c].dissipation = double(0)
  end
end

__demand(__parallel, __cuda)
task Flow_ComputeDissipationX($Fluid : region(ispace(int3d), Fluid_columns), $Flow_constantVisc : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32, $Grid_xBnum : int32, $Grid_xCellWidth : double, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipationFlux), writes($Fluid.dissipationFlux), reads($Fluid.temperature), reads($Fluid.velocity), reads($Fluid.velocityGradientY), reads($Fluid.velocityGradientZ)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) or (max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))==int32(1))) then
      var $muFace : double = (double(0.5)*(GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)+GetDynamicViscosity($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)))
      var $velocityFace : double[3] = double[3](array(double(0), double(0), double(0)))
      var $velocityX_YFace : double = double(double(0))
      var $velocityX_ZFace : double = double(double(0))
      var $velocityY_YFace : double = double(double(0))
      var $velocityZ_ZFace : double = double(double(0))
      $velocityFace = vs_mul_double_3(vv_add_double_3($Fluid[$c].velocity, $Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity), double(0.5))
      $velocityX_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(0)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientY[int32(0)]))
      $velocityX_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(0)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientZ[int32(0)]))
      $velocityY_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(1)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientY[int32(1)]))
      $velocityZ_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(2)]+$Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocityGradientZ[int32(2)]))
      var $velocityX_XFace : double = double(double(0))
      var $velocityY_XFace : double = double(double(0))
      var $velocityZ_XFace : double = double(double(0))
      var $temperature_XFace : double = double(double(0))
      $velocityX_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity[int32(0)]-$Fluid[$c].velocity[int32(0)]))
      $velocityY_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity[int32(1)]-$Fluid[$c].velocity[int32(1)]))
      $velocityZ_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity[int32(2)]-$Fluid[$c].velocity[int32(2)]))
      $temperature_XFace = (double(0.5)*($Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].temperature-$Fluid[$c].temperature))
      $velocityX_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      $velocityY_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      $velocityZ_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      $temperature_XFace *= (1/($Grid_xCellWidth*double(0.5)))
      var $sigmaXX : double = (($muFace*(((double(4)*$velocityX_XFace)-(double(2)*$velocityY_YFace))-(double(2)*$velocityZ_ZFace)))/double(3))
      var $sigmaYX : double = ($muFace*($velocityY_XFace+$velocityX_YFace))
      var $sigmaZX : double = ($muFace*($velocityZ_XFace+$velocityX_ZFace))
      var $usigma : double = ((($velocityFace[int32(0)]*$sigmaXX)+($velocityFace[int32(1)]*$sigmaYX))+($velocityFace[int32(2)]*$sigmaZX))
      $Fluid[$c].dissipationFlux = $usigma
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateDissipationX($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xCellWidth : double, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipation), writes($Fluid.dissipation), reads($Fluid.dissipationFlux)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $Fluid[$c].dissipation += (($Fluid[$c].dissipationFlux-$Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].dissipationFlux)/$Grid_xCellWidth)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_ComputeDissipationY($Fluid : region(ispace(int3d), Fluid_columns), $Flow_constantVisc : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yCellWidth : double, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipationFlux), writes($Fluid.dissipationFlux), reads($Fluid.temperature), reads($Fluid.velocity), reads($Fluid.velocityGradientX), reads($Fluid.velocityGradientZ)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))==int32(1))) then
      var $muFace : double = (double(0.5)*(GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)+GetDynamicViscosity($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)))
      var $velocityFace : double[3] = double[3](array(double(0), double(0), double(0)))
      var $velocityY_XFace : double = double(double(0))
      var $velocityY_ZFace : double = double(double(0))
      var $velocityX_XFace : double = double(double(0))
      var $velocityZ_ZFace : double = double(double(0))
      $velocityFace = vs_mul_double_3(vv_add_double_3($Fluid[$c].velocity, $Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity), double(0.5))
      $velocityY_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(1)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientX[int32(1)]))
      $velocityY_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(1)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientZ[int32(1)]))
      $velocityX_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(0)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientX[int32(0)]))
      $velocityZ_ZFace = (double(0.5)*($Fluid[$c].velocityGradientZ[int32(2)]+$Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocityGradientZ[int32(2)]))
      var $velocityX_YFace : double = double(double(0))
      var $velocityY_YFace : double = double(double(0))
      var $velocityZ_YFace : double = double(double(0))
      var $temperature_YFace : double = double(double(0))
      $velocityX_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity[int32(0)]-$Fluid[$c].velocity[int32(0)]))
      $velocityY_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity[int32(1)]-$Fluid[$c].velocity[int32(1)]))
      $velocityZ_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity[int32(2)]-$Fluid[$c].velocity[int32(2)]))
      $temperature_YFace = (double(0.5)*($Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].temperature-$Fluid[$c].temperature))
      $velocityX_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      $velocityY_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      $velocityZ_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      $temperature_YFace *= (1/($Grid_yCellWidth*double(0.5)))
      var $sigmaXY : double = ($muFace*($velocityX_YFace+$velocityY_XFace))
      var $sigmaYY : double = (($muFace*(((double(4)*$velocityY_YFace)-(double(2)*$velocityX_XFace))-(double(2)*$velocityZ_ZFace)))/double(3))
      var $sigmaZY : double = ($muFace*($velocityZ_YFace+$velocityY_ZFace))
      var $usigma : double = ((($velocityFace[int32(0)]*$sigmaXY)+($velocityFace[int32(1)]*$sigmaYY))+($velocityFace[int32(2)]*$sigmaZY))
      $Fluid[$c].dissipationFlux = $usigma
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateDissipationY($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yCellWidth : double, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipation), writes($Fluid.dissipation), reads($Fluid.dissipationFlux)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $Fluid[$c].dissipation += (($Fluid[$c].dissipationFlux-$Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].dissipationFlux)/$Grid_yCellWidth)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_ComputeDissipationZ($Fluid : region(ispace(int3d), Fluid_columns), $Flow_constantVisc : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zCellWidth : double, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipationFlux), writes($Fluid.dissipationFlux), reads($Fluid.temperature), reads($Fluid.velocity), reads($Fluid.velocityGradientX), reads($Fluid.velocityGradientY)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if ((not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))==int32(1))) then
      var $muFace : double = (double(0.5)*(GetDynamicViscosity($Fluid[$c].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)+GetDynamicViscosity($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)))
      var $velocityFace : double[3] = double[3](array(double(0), double(0), double(0)))
      var $velocityZ_XFace : double = double(double(0))
      var $velocityZ_YFace : double = double(double(0))
      var $velocityX_XFace : double = double(double(0))
      var $velocityY_YFace : double = double(double(0))
      $velocityFace = vs_mul_double_3(vv_add_double_3($Fluid[$c].velocity, $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity), double(0.5))
      $velocityZ_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(2)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientX[int32(2)]))
      $velocityZ_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(2)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientY[int32(2)]))
      $velocityX_XFace = (double(0.5)*($Fluid[$c].velocityGradientX[int32(0)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientX[int32(0)]))
      $velocityY_YFace = (double(0.5)*($Fluid[$c].velocityGradientY[int32(1)]+$Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocityGradientY[int32(1)]))
      var $velocityX_ZFace : double = double(double(0))
      var $velocityY_ZFace : double = double(double(0))
      var $velocityZ_ZFace : double = double(double(0))
      var $temperature_ZFace : double = double(double(0))
      $velocityX_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity[int32(0)]-$Fluid[$c].velocity[int32(0)]))
      $velocityY_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity[int32(1)]-$Fluid[$c].velocity[int32(1)]))
      $velocityZ_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity[int32(2)]-$Fluid[$c].velocity[int32(2)]))
      $temperature_ZFace = (double(0.5)*($Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature-$Fluid[$c].temperature))
      $velocityX_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      $velocityY_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      $velocityZ_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      $temperature_ZFace *= (1/($Grid_zCellWidth*double(0.5)))
      var $sigmaXZ : double = ($muFace*($velocityX_ZFace+$velocityZ_XFace))
      var $sigmaYZ : double = ($muFace*($velocityY_ZFace+$velocityZ_YFace))
      var $sigmaZZ : double = (($muFace*(((double(4)*$velocityZ_ZFace)-(double(2)*$velocityX_XFace))-(double(2)*$velocityY_YFace)))/double(3))
      var $usigma : double = ((($velocityFace[int32(0)]*$sigmaXZ)+($velocityFace[int32(1)]*$sigmaYZ))+($velocityFace[int32(2)]*$sigmaZZ))
      $Fluid[$c].dissipationFlux = $usigma
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateDissipationZ($Fluid : region(ispace(int3d), Fluid_columns), $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zCellWidth : double, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipation), writes($Fluid.dissipation), reads($Fluid.dissipationFlux)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $Fluid[$c].dissipation += (($Fluid[$c].dissipationFlux-$Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].dissipationFlux)/$Grid_zCellWidth)
    else
    end
  end
end

__demand(__parallel)
task CalculateAveragePD($Fluid : region(ispace(int3d), Fluid_columns), $Grid_cellVolume : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.PD)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc += ($Fluid[$c].PD*$Grid_cellVolume)
    else
    end
  end
  return $acc
end

__demand(__parallel)
task CalculateAverageDissipation($Fluid : region(ispace(int3d), Fluid_columns), $Grid_cellVolume : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.dissipation)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc += ($Fluid[$c].dissipation*$Grid_cellVolume)
    else
    end
  end
  return $acc
end

__demand(__parallel)
task CalculateAverageK($Fluid : region(ispace(int3d), Fluid_columns), $Grid_cellVolume : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rho), reads($Fluid.velocity)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $acc += (((double(0.5)*$Fluid[$c].rho)*dot_double_3($Fluid[$c].velocity, $Fluid[$c].velocity))*$Grid_cellVolume)
    else
    end
  end
  return $acc
end

__demand(__parallel)
task Flow_AddTurbulentSource($Fluid : region(ispace(int3d), Fluid_columns), $Flow_averageDissipation : double, $Flow_averageK : double, $Flow_averagePD : double, $Grid_cellVolume : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rho), reads($Fluid.rhoEnergy_t), writes($Fluid.rhoEnergy_t), reads($Fluid.rhoVelocity_t), writes($Fluid.rhoVelocity_t), reads($Fluid.velocity)
do
  var $acc : double = double(0)
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      var $W : double = double(double(0))
      var $A : double = double(double(0))
      var $G : double = double(double(0))
      var $t_o : double = double(double(0))
      var $K_o : double = double(double(0))
      var $force : double[3] = double[3](array(double(0), double(0), double(0)))
      $W = ($Flow_averagePD+$Flow_averageDissipation)
      $G = double(300)
      $t_o = double(3.00889e-06)
      $K_o = double(66.27348)
      $A = (((-$W)-(($G*($Flow_averageK-$K_o))/$t_o))/(double(2)*$Flow_averageK))
      $force = vs_mul_double_3($Fluid[$c].velocity, ($Fluid[$c].rho*$A))
      var $tmp : double[3] = $force
      var $v : double[3] = $Fluid[$c].rhoVelocity_t
      $v[0] += $tmp[0]
      $v[1] += $tmp[1]
      $v[2] += $tmp[2]
      $Fluid[$c].rhoVelocity_t = $v
      $Fluid[$c].rhoEnergy_t += dot_double_3($force, $Fluid[$c].velocity)
      $acc += (dot_double_3($force, $Fluid[$c].velocity)*$Grid_cellVolume)
    else
    end
  end
  return $acc
end

__demand(__parallel, __cuda)
task Flow_AdjustTurbulentSource($Fluid : region(ispace(int3d), Fluid_columns), $Flow_averageFe : double, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_zBnum : int32, $Grid_zNum : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rhoEnergy_t), writes($Fluid.rhoEnergy_t)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    if (not ((((((max(int32((uint64($Grid_xBnum)-int3d($c).x)), int32(0))>int32(0)) or (max(int32((int3d($c).x-uint64((($Grid_xNum+$Grid_xBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_yBnum)-int3d($c).y)), int32(0))>int32(0))) or (max(int32((int3d($c).y-uint64((($Grid_yNum+$Grid_yBnum)-int32(1))))), int32(0))>int32(0))) or (max(int32((uint64($Grid_zBnum)-int3d($c).z)), int32(0))>int32(0))) or (max(int32((int3d($c).z-uint64((($Grid_zNum+$Grid_zBnum)-int32(1))))), int32(0))>int32(0)))) then
      $Fluid[$c].rhoEnergy_t += (-$Flow_averageFe)
    else
    end
  end
end

__demand(__inline)
task locate($pos : double[3], $BC_xBCPeriodic : bool, $BC_yBCPeriodic : bool, $BC_zBCPeriodic : bool, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_xOrigin : double, $Grid_xWidth : double, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_yOrigin : double, $Grid_yWidth : double, $Grid_zBnum : int32, $Grid_zNum : int32, $Grid_zOrigin : double, $Grid_zWidth : double) : int3d
-- leaf (false), inner (false), idempotent (false)
  var $xcw : double = ($Grid_xWidth/double($Grid_xNum))
  var $xro : double = ($Grid_xOrigin-(double($Grid_xBnum)*$xcw))
  var $xpos : double = (($pos[int32(0)]-$xro)/$xcw)
  var $xrnum : int32 = ($Grid_xNum+(int32(2)*$Grid_xBnum))
  var $xidx : uint64
  if $BC_xBCPeriodic then
    $xidx = (uint64((fmod($xpos, double($xrnum))+double($xrnum)))%uint64($xrnum))
  else
    $xidx = uint64(max(double(0), min(double(($xrnum-int32(1))), $xpos)))
  end
  var $ycw : double = ($Grid_yWidth/double($Grid_yNum))
  var $yro : double = ($Grid_yOrigin-(double($Grid_yBnum)*$ycw))
  var $ypos : double = (($pos[int32(1)]-$yro)/$ycw)
  var $yrnum : int32 = ($Grid_yNum+(int32(2)*$Grid_yBnum))
  var $yidx : uint64
  if $BC_yBCPeriodic then
    $yidx = (uint64((fmod($ypos, double($yrnum))+double($yrnum)))%uint64($yrnum))
  else
    $yidx = uint64(max(double(0), min(double(($yrnum-int32(1))), $ypos)))
  end
  var $zcw : double = ($Grid_zWidth/double($Grid_zNum))
  var $zro : double = ($Grid_zOrigin-(double($Grid_zBnum)*$zcw))
  var $zpos : double = (($pos[int32(2)]-$zro)/$zcw)
  var $zrnum : int32 = ($Grid_zNum+(int32(2)*$Grid_zBnum))
  var $zidx : uint64
  if $BC_zBCPeriodic then
    $zidx = (uint64((fmod($zpos, double($zrnum))+double($zrnum)))%uint64($zrnum))
  else
    $zidx = uint64(max(double(0), min(double(($zrnum-int32(1))), $zpos)))
  end
  return int3d({$xidx, $yidx, $zidx})
end

__demand(__cuda)
task Particles_LocateInCells($particles : region(ispace(int1d), particles_columns), $BC_xBCPeriodic : bool, $BC_yBCPeriodic : bool, $BC_zBCPeriodic : bool, $Grid_xBnum : int32, $Grid_xNum : int32, $Grid_xOrigin : double, $Grid_xWidth : double, $Grid_yBnum : int32, $Grid_yNum : int32, $Grid_yOrigin : double, $Grid_yWidth : double, $Grid_zBnum : int32, $Grid_zNum : int32, $Grid_zOrigin : double, $Grid_zWidth : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.cell), writes($particles.cell), reads($particles.position), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $particles[$p].cell = locate($particles[$p].position, $BC_xBCPeriodic, $BC_yBCPeriodic, $BC_zBCPeriodic, $Grid_xBnum, $Grid_xNum, $Grid_xOrigin, $Grid_xWidth, $Grid_yBnum, $Grid_yNum, $Grid_yOrigin, $Grid_yWidth, $Grid_zBnum, $Grid_zNum, $Grid_zOrigin, $Grid_zWidth)
    else
    end
  end
end

__demand(__inline)
task Fluid_elemColor($idx : int3d, $xNum : int32, $yNum : int32, $zNum : int32, $xBnum : int32, $yBnum : int32, $zBnum : int32, $NX_ : int32, $NY_ : int32, $NZ_ : int32) : int3d
-- leaf (false), inner (false), idempotent (false)
  $idx.x = min(max($idx.x, $xBnum), (($xNum+$xBnum)-1))
  $idx.y = min(max($idx.y, $yBnum), (($yNum+$yBnum)-1))
  $idx.z = min(max($idx.z, $zBnum), (($zNum+$zBnum)-1))
  return int3d({(($idx.x-$xBnum)/($xNum/$NX_)), (($idx.y-$yBnum)/($yNum/$NY_)), (($idx.z-$zBnum)/($zNum/$NZ_))})
end

   terra particles_pushElement(dst : &opaque,idx : int32,src : particles_columns) : {}
       var ptr : &int8 = [&int8](dst) + idx * 376
       memcpy([&opaque](ptr), [&opaque](&src), [uint64](376))
   end
   terra particles_getBasePointer(pr : legion_physical_region_t,fid : uint32,runtime : legion_runtime_t) : &opaque
       var acc : legion_accessor_array_1d_t = legion_physical_region_get_field_accessor_array_1d(pr, fid)
       var lr : legion_logical_region_t = legion_physical_region_get_logical_region(pr)
       var domain : legion_domain_t = legion_index_space_get_domain(runtime, lr.index_space)
       var rect : legion_rect_1d_t = legion_domain_get_rect_1d(domain)
       var subrect : legion_rect_1d_t
       var offsets : legion_byte_offset_t[1]
       var p : &opaque = legion_accessor_array_1d_raw_rect_ptr(acc, rect, &subrect, &[&legion_byte_offset_t](offsets)[0])
       legion_accessor_array_1d_destroy(acc)
       return p
   end
   terra particles_getOffset() : int64
       var x : particles_columns
       return [&int8](&x.__valid) - [&int8](&x)
   end
task particles_pushAll($partColor : int3d, $r : region(ispace(int1d), particles_columns), $q0 : region(ispace(int1d), int8[376]), $q1 : region(ispace(int1d), int8[376]), $q2 : region(ispace(int1d), int8[376]), $q3 : region(ispace(int1d), int8[376]), $q4 : region(ispace(int1d), int8[376]), $q5 : region(ispace(int1d), int8[376]), $q6 : region(ispace(int1d), int8[376]), $q7 : region(ispace(int1d), int8[376]), $q8 : region(ispace(int1d), int8[376]), $q9 : region(ispace(int1d), int8[376]), $q10 : region(ispace(int1d), int8[376]), $q11 : region(ispace(int1d), int8[376]), $q12 : region(ispace(int1d), int8[376]), $q13 : region(ispace(int1d), int8[376]), $q14 : region(ispace(int1d), int8[376]), $q15 : region(ispace(int1d), int8[376]), $q16 : region(ispace(int1d), int8[376]), $q17 : region(ispace(int1d), int8[376]), $q18 : region(ispace(int1d), int8[376]), $q19 : region(ispace(int1d), int8[376]), $q20 : region(ispace(int1d), int8[376]), $q21 : region(ispace(int1d), int8[376]), $q22 : region(ispace(int1d), int8[376]), $q23 : region(ispace(int1d), int8[376]), $q24 : region(ispace(int1d), int8[376]), $q25 : region(ispace(int1d), int8[376]), $rngXNum : int32, $rngYNum : int32, $rngZNum : int32, $rngXbnum : int32, $rngYbnum : int32, $rngZbnum : int32, $NX_ : int32, $NY_ : int32, $NZ_ : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($r), writes($r.__valid), reads($q0), writes($q0), reads($q1), writes($q1), reads($q2), writes($q2), reads($q3), writes($q3), reads($q4), writes($q4), reads($q5), writes($q5), reads($q6), writes($q6), reads($q7), writes($q7), reads($q8), writes($q8), reads($q9), writes($q9), reads($q10), writes($q10), reads($q11), writes($q11), reads($q12), writes($q12), reads($q13), writes($q13), reads($q14), writes($q14), reads($q15), writes($q15), reads($q16), writes($q16), reads($q17), writes($q17), reads($q18), writes($q18), reads($q19), writes($q19), reads($q20), writes($q20), reads($q21), writes($q21), reads($q22), writes($q22), reads($q23), writes($q23), reads($q24), writes($q24), reads($q25), writes($q25)
do
  for $qPtr : int1d(int8[376], $q0) in $q0 do
    $q0[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr0 : &opaque = particles_getBasePointer(__physical($q0)[0], __fields($q0)[0], __runtime())
  for $qPtr : int1d(int8[376], $q1) in $q1 do
    $q1[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr1 : &opaque = particles_getBasePointer(__physical($q1)[0], __fields($q1)[0], __runtime())
  for $qPtr : int1d(int8[376], $q2) in $q2 do
    $q2[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr2 : &opaque = particles_getBasePointer(__physical($q2)[0], __fields($q2)[0], __runtime())
  for $qPtr : int1d(int8[376], $q3) in $q3 do
    $q3[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr3 : &opaque = particles_getBasePointer(__physical($q3)[0], __fields($q3)[0], __runtime())
  for $qPtr : int1d(int8[376], $q4) in $q4 do
    $q4[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr4 : &opaque = particles_getBasePointer(__physical($q4)[0], __fields($q4)[0], __runtime())
  for $qPtr : int1d(int8[376], $q5) in $q5 do
    $q5[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr5 : &opaque = particles_getBasePointer(__physical($q5)[0], __fields($q5)[0], __runtime())
  for $qPtr : int1d(int8[376], $q6) in $q6 do
    $q6[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr6 : &opaque = particles_getBasePointer(__physical($q6)[0], __fields($q6)[0], __runtime())
  for $qPtr : int1d(int8[376], $q7) in $q7 do
    $q7[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr7 : &opaque = particles_getBasePointer(__physical($q7)[0], __fields($q7)[0], __runtime())
  for $qPtr : int1d(int8[376], $q8) in $q8 do
    $q8[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr8 : &opaque = particles_getBasePointer(__physical($q8)[0], __fields($q8)[0], __runtime())
  for $qPtr : int1d(int8[376], $q9) in $q9 do
    $q9[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr9 : &opaque = particles_getBasePointer(__physical($q9)[0], __fields($q9)[0], __runtime())
  for $qPtr : int1d(int8[376], $q10) in $q10 do
    $q10[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr10 : &opaque = particles_getBasePointer(__physical($q10)[0], __fields($q10)[0], __runtime())
  for $qPtr : int1d(int8[376], $q11) in $q11 do
    $q11[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr11 : &opaque = particles_getBasePointer(__physical($q11)[0], __fields($q11)[0], __runtime())
  for $qPtr : int1d(int8[376], $q12) in $q12 do
    $q12[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr12 : &opaque = particles_getBasePointer(__physical($q12)[0], __fields($q12)[0], __runtime())
  for $qPtr : int1d(int8[376], $q13) in $q13 do
    $q13[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr13 : &opaque = particles_getBasePointer(__physical($q13)[0], __fields($q13)[0], __runtime())
  for $qPtr : int1d(int8[376], $q14) in $q14 do
    $q14[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr14 : &opaque = particles_getBasePointer(__physical($q14)[0], __fields($q14)[0], __runtime())
  for $qPtr : int1d(int8[376], $q15) in $q15 do
    $q15[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr15 : &opaque = particles_getBasePointer(__physical($q15)[0], __fields($q15)[0], __runtime())
  for $qPtr : int1d(int8[376], $q16) in $q16 do
    $q16[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr16 : &opaque = particles_getBasePointer(__physical($q16)[0], __fields($q16)[0], __runtime())
  for $qPtr : int1d(int8[376], $q17) in $q17 do
    $q17[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr17 : &opaque = particles_getBasePointer(__physical($q17)[0], __fields($q17)[0], __runtime())
  for $qPtr : int1d(int8[376], $q18) in $q18 do
    $q18[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr18 : &opaque = particles_getBasePointer(__physical($q18)[0], __fields($q18)[0], __runtime())
  for $qPtr : int1d(int8[376], $q19) in $q19 do
    $q19[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr19 : &opaque = particles_getBasePointer(__physical($q19)[0], __fields($q19)[0], __runtime())
  for $qPtr : int1d(int8[376], $q20) in $q20 do
    $q20[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr20 : &opaque = particles_getBasePointer(__physical($q20)[0], __fields($q20)[0], __runtime())
  for $qPtr : int1d(int8[376], $q21) in $q21 do
    $q21[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr21 : &opaque = particles_getBasePointer(__physical($q21)[0], __fields($q21)[0], __runtime())
  for $qPtr : int1d(int8[376], $q22) in $q22 do
    $q22[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr22 : &opaque = particles_getBasePointer(__physical($q22)[0], __fields($q22)[0], __runtime())
  for $qPtr : int1d(int8[376], $q23) in $q23 do
    $q23[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr23 : &opaque = particles_getBasePointer(__physical($q23)[0], __fields($q23)[0], __runtime())
  for $qPtr : int1d(int8[376], $q24) in $q24 do
    $q24[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr24 : &opaque = particles_getBasePointer(__physical($q24)[0], __fields($q24)[0], __runtime())
  for $qPtr : int1d(int8[376], $q25) in $q25 do
    $q25[$qPtr][368LL] = int8(false)
  end
  var $qBasePtr25 : &opaque = particles_getBasePointer(__physical($q25)[0], __fields($q25)[0], __runtime())
  for $rPtr : int1d(particles_columns, $r) in $r do
    if (@$rPtr).__valid then
      var $elemColor : int3d = Fluid_elemColor((@$rPtr).cell, $rngXNum, $rngYNum, $rngZNum, $rngXbnum, $rngYbnum, $rngZbnum, $NX_, $NY_, $NZ_)
      if ($elemColor~=$partColor) then
        do
          var $colorOff : int3d = int3d({0, 0, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q0) in $q0 do
              if (not bool($q0[$qPtr][368LL])) then
                particles_pushElement($qBasePtr0, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q0[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({0, 0, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q1) in $q1 do
              if (not bool($q1[$qPtr][368LL])) then
                particles_pushElement($qBasePtr1, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q1[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({0, 1, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q2) in $q2 do
              if (not bool($q2[$qPtr][368LL])) then
                particles_pushElement($qBasePtr2, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q2[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({0, 1, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q3) in $q3 do
              if (not bool($q3[$qPtr][368LL])) then
                particles_pushElement($qBasePtr3, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q3[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({0, 1, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q4) in $q4 do
              if (not bool($q4[$qPtr][368LL])) then
                particles_pushElement($qBasePtr4, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q4[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({0, -1, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q5) in $q5 do
              if (not bool($q5[$qPtr][368LL])) then
                particles_pushElement($qBasePtr5, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q5[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({0, -1, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q6) in $q6 do
              if (not bool($q6[$qPtr][368LL])) then
                particles_pushElement($qBasePtr6, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q6[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({0, -1, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q7) in $q7 do
              if (not bool($q7[$qPtr][368LL])) then
                particles_pushElement($qBasePtr7, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q7[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, 0, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q8) in $q8 do
              if (not bool($q8[$qPtr][368LL])) then
                particles_pushElement($qBasePtr8, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q8[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, 0, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q9) in $q9 do
              if (not bool($q9[$qPtr][368LL])) then
                particles_pushElement($qBasePtr9, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q9[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, 0, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q10) in $q10 do
              if (not bool($q10[$qPtr][368LL])) then
                particles_pushElement($qBasePtr10, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q10[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, 1, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q11) in $q11 do
              if (not bool($q11[$qPtr][368LL])) then
                particles_pushElement($qBasePtr11, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q11[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, 1, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q12) in $q12 do
              if (not bool($q12[$qPtr][368LL])) then
                particles_pushElement($qBasePtr12, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q12[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, 1, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q13) in $q13 do
              if (not bool($q13[$qPtr][368LL])) then
                particles_pushElement($qBasePtr13, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q13[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, -1, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q14) in $q14 do
              if (not bool($q14[$qPtr][368LL])) then
                particles_pushElement($qBasePtr14, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q14[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, -1, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q15) in $q15 do
              if (not bool($q15[$qPtr][368LL])) then
                particles_pushElement($qBasePtr15, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q15[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({1, -1, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q16) in $q16 do
              if (not bool($q16[$qPtr][368LL])) then
                particles_pushElement($qBasePtr16, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q16[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, 0, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q17) in $q17 do
              if (not bool($q17[$qPtr][368LL])) then
                particles_pushElement($qBasePtr17, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q17[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, 0, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q18) in $q18 do
              if (not bool($q18[$qPtr][368LL])) then
                particles_pushElement($qBasePtr18, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q18[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, 0, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q19) in $q19 do
              if (not bool($q19[$qPtr][368LL])) then
                particles_pushElement($qBasePtr19, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q19[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, 1, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q20) in $q20 do
              if (not bool($q20[$qPtr][368LL])) then
                particles_pushElement($qBasePtr20, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q20[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, 1, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q21) in $q21 do
              if (not bool($q21[$qPtr][368LL])) then
                particles_pushElement($qBasePtr21, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q21[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, 1, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q22) in $q22 do
              if (not bool($q22[$qPtr][368LL])) then
                particles_pushElement($qBasePtr22, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q22[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, -1, 0})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q23) in $q23 do
              if (not bool($q23[$qPtr][368LL])) then
                particles_pushElement($qBasePtr23, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q23[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, -1, 1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q24) in $q24 do
              if (not bool($q24[$qPtr][368LL])) then
                particles_pushElement($qBasePtr24, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q24[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        do
          var $colorOff : int3d = int3d({-1, -1, -1})
          if ((@$rPtr).__valid and ($elemColor==((($partColor+$colorOff)+{$NX_, $NY_, $NZ_})%{$NX_, $NY_, $NZ_}))) then
            var $idx : int32 = 0
            for $qPtr : int1d(int8[376], $q25) in $q25 do
              if (not bool($q25[$qPtr][368LL])) then
                particles_pushElement($qBasePtr25, $idx, $r[$rPtr])
                (@$rPtr).__valid = false
                base.assert(bool($q25[$qPtr][368LL]), "Element did not get copied properly")
                break
              else
              end
              $idx += 1
            end
            base.assert((not (@$rPtr).__valid), "Transfer queue ran out of space")
          else
          end
        end
        base.assert((not (@$rPtr).__valid), "Element moved past predicted stencil")
      else
      end
    else
    end
  end
end

  terra particles_pullElement(src : &int8) : particles_columns
      var dst : particles_columns
      memcpy([&opaque](&dst), [&opaque](src), [uint64](376))
      return dst
  end
task particles_pullAll($color : int3d, $r : region(ispace(int1d), particles_columns), $q0 : region(ispace(int1d), int8[376]), $q1 : region(ispace(int1d), int8[376]), $q2 : region(ispace(int1d), int8[376]), $q3 : region(ispace(int1d), int8[376]), $q4 : region(ispace(int1d), int8[376]), $q5 : region(ispace(int1d), int8[376]), $q6 : region(ispace(int1d), int8[376]), $q7 : region(ispace(int1d), int8[376]), $q8 : region(ispace(int1d), int8[376]), $q9 : region(ispace(int1d), int8[376]), $q10 : region(ispace(int1d), int8[376]), $q11 : region(ispace(int1d), int8[376]), $q12 : region(ispace(int1d), int8[376]), $q13 : region(ispace(int1d), int8[376]), $q14 : region(ispace(int1d), int8[376]), $q15 : region(ispace(int1d), int8[376]), $q16 : region(ispace(int1d), int8[376]), $q17 : region(ispace(int1d), int8[376]), $q18 : region(ispace(int1d), int8[376]), $q19 : region(ispace(int1d), int8[376]), $q20 : region(ispace(int1d), int8[376]), $q21 : region(ispace(int1d), int8[376]), $q22 : region(ispace(int1d), int8[376]), $q23 : region(ispace(int1d), int8[376]), $q24 : region(ispace(int1d), int8[376]), $q25 : region(ispace(int1d), int8[376]))
-- leaf (false), inner (false), idempotent (false)
where
  reads($r), writes($r), reads($q0), reads($q1), reads($q2), reads($q3), reads($q4), reads($q5), reads($q6), reads($q7), reads($q8), reads($q9), reads($q10), reads($q11), reads($q12), reads($q13), reads($q14), reads($q15), reads($q16), reads($q17), reads($q18), reads($q19), reads($q20), reads($q21), reads($q22), reads($q23), reads($q24), reads($q25)
do
  for $qPtr : int1d(int8[376], $q0) in $q0 do
    if bool($q0[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q0[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q1) in $q1 do
    if bool($q1[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q1[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q2) in $q2 do
    if bool($q2[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q2[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q3) in $q3 do
    if bool($q3[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q3[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q4) in $q4 do
    if bool($q4[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q4[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q5) in $q5 do
    if bool($q5[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q5[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q6) in $q6 do
    if bool($q6[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q6[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q7) in $q7 do
    if bool($q7[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q7[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q8) in $q8 do
    if bool($q8[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q8[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q9) in $q9 do
    if bool($q9[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q9[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q10) in $q10 do
    if bool($q10[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q10[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q11) in $q11 do
    if bool($q11[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q11[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q12) in $q12 do
    if bool($q12[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q12[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q13) in $q13 do
    if bool($q13[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q13[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q14) in $q14 do
    if bool($q14[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q14[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q15) in $q15 do
    if bool($q15[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q15[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q16) in $q16 do
    if bool($q16[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q16[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q17) in $q17 do
    if bool($q17[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q17[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q18) in $q18 do
    if bool($q18[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q18[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q19) in $q19 do
    if bool($q19[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q19[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q20) in $q20 do
    if bool($q20[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q20[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q21) in $q21 do
    if bool($q21[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q21[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q22) in $q22 do
    if bool($q22[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q22[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q23) in $q23 do
    if bool($q23[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q23[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q24) in $q24 do
    if bool($q24[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q24[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
  for $qPtr : int1d(int8[376], $q25) in $q25 do
    if bool($q25[$qPtr][368LL]) then
      var $copied : bool = false
      for $rPtr : int1d(particles_columns, $r) in $r do
        if (not (@$rPtr).__valid) then
          $r[$rPtr] = particles_pullElement(&int8($q25[$qPtr]))
          $copied = true
          base.assert($r[$rPtr].__valid, "Pulled particle was not copied correctly")
          break
        else
        end
      end
      base.assert($copied, "Ran out of space on sub-partition")
    else
    end
  end
end

__demand(__inline)
task TrilinearInterpolateVelocity($xyz : double[3], $c000 : double[3], $c100 : double[3], $c010 : double[3], $c110 : double[3], $c001 : double[3], $c101 : double[3], $c011 : double[3], $c111 : double[3], $Grid_xCellWidth : double, $Grid_xRealOrigin : double, $Grid_yCellWidth : double, $Grid_yRealOrigin : double, $Grid_zCellWidth : double, $Grid_zRealOrigin : double) : double[3]
-- leaf (false), inner (false), idempotent (false)
  var $dX : double = fmod(((($xyz[int32(0)]-$Grid_xRealOrigin)/$Grid_xCellWidth)+double(0.5)), double(1))
  var $dY : double = fmod(((($xyz[int32(1)]-$Grid_yRealOrigin)/$Grid_yCellWidth)+double(0.5)), double(1))
  var $dZ : double = fmod(((($xyz[int32(2)]-$Grid_zRealOrigin)/$Grid_zCellWidth)+double(0.5)), double(1))
  var $oneMinusdX : double = (double(1)-$dX)
  var $oneMinusdY : double = (double(1)-$dY)
  var $oneMinusdZ : double = (double(1)-$dZ)
  var $weight00 : double[3] = vv_add_double_3(vs_mul_double_3($c000, $oneMinusdX), vs_mul_double_3($c100, $dX))
  var $weight10 : double[3] = vv_add_double_3(vs_mul_double_3($c010, $oneMinusdX), vs_mul_double_3($c110, $dX))
  var $weight01 : double[3] = vv_add_double_3(vs_mul_double_3($c001, $oneMinusdX), vs_mul_double_3($c101, $dX))
  var $weight11 : double[3] = vv_add_double_3(vs_mul_double_3($c011, $oneMinusdX), vs_mul_double_3($c111, $dX))
  var $weight0 : double[3] = vv_add_double_3(vs_mul_double_3($weight00, $oneMinusdY), vs_mul_double_3($weight10, $dY))
  var $weight1 : double[3] = vv_add_double_3(vs_mul_double_3($weight01, $oneMinusdY), vs_mul_double_3($weight11, $dY))
  return vv_add_double_3(vs_mul_double_3($weight0, $oneMinusdZ), vs_mul_double_3($weight1, $dZ))
end

__demand(__inline)
task InterpolateTriVelocity($c : int3d, $xyz : double[3], $Fluid : region(ispace(int3d), Fluid_columns), $Grid_xCellWidth : double, $Grid_xRealOrigin : double, $Grid_yCellWidth : double, $Grid_yRealOrigin : double, $Grid_zCellWidth : double, $Grid_zRealOrigin : double) : double[3]
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.centerCoordinates), reads($Fluid.velocity)
do
  var $velocity000 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity100 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity010 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity110 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity001 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity101 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity011 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity111 : double[3] = double[3](array(double(0), double(0), double(0)))
  var $velocity0 : double[3] = $Fluid[$c].velocity
  if ($xyz[int32(0)]>$Fluid[$c].centerCoordinates[int32(0)]) then
    var $velocityb : double[3] = $Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].velocity
    if ($xyz[int32(1)]>$Fluid[$c].centerCoordinates[int32(1)]) then
      var $velocityaa : double[3] = $Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity
      var $velocityab : double[3] = $Fluid[(($c+{1, 1, 0})%$Fluid.bounds)].velocity
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $velocity000 = $velocity0
        $velocity100 = $velocityb
        $velocity010 = $velocityaa
        $velocity110 = $velocityab
        $velocity001 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity
        $velocity101 = $Fluid[(($c+{1, 0, 1})%$Fluid.bounds)].velocity
        $velocity011 = $Fluid[(($c+{0, 1, 1})%$Fluid.bounds)].velocity
        $velocity111 = $Fluid[(($c+{1, 1, 1})%$Fluid.bounds)].velocity
      else
        $velocity000 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].velocity
        $velocity100 = $Fluid[(($c+{1, 0, -1})%$Fluid.bounds)].velocity
        $velocity010 = $Fluid[(($c+{0, 1, -1})%$Fluid.bounds)].velocity
        $velocity110 = $Fluid[(($c+{1, 1, -1})%$Fluid.bounds)].velocity
        $velocity001 = $velocity0
        $velocity101 = $velocityb
        $velocity011 = $velocityaa
        $velocity111 = $velocityab
      end
    else
      var $velocityaa : double[3] = $Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].velocity
      var $velocityab : double[3] = $Fluid[(($c+{1, -1, 0})%$Fluid.bounds)].velocity
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $velocity000 = $velocityaa
        $velocity100 = $velocityab
        $velocity010 = $velocity0
        $velocity110 = $velocityb
        $velocity001 = $Fluid[(($c+{0, -1, 1})%$Fluid.bounds)].velocity
        $velocity101 = $Fluid[(($c+{1, -1, 1})%$Fluid.bounds)].velocity
        $velocity011 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity
        $velocity111 = $Fluid[(($c+{1, 0, 1})%$Fluid.bounds)].velocity
      else
        $velocity000 = $Fluid[(($c+{0, -1, -1})%$Fluid.bounds)].velocity
        $velocity100 = $Fluid[(($c+{1, -1, -1})%$Fluid.bounds)].velocity
        $velocity010 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].velocity
        $velocity110 = $Fluid[(($c+{1, 0, -1})%$Fluid.bounds)].velocity
        $velocity001 = $velocityaa
        $velocity101 = $velocityab
        $velocity011 = $velocity0
        $velocity111 = $velocityb
      end
    end
  else
    var $velocitya : double[3] = $Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].velocity
    if ($xyz[int32(1)]>$Fluid[$c].centerCoordinates[int32(1)]) then
      var $velocityaa : double[3] = $Fluid[(($c+{-1, 1, 0})%$Fluid.bounds)].velocity
      var $velocityab : double[3] = $Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].velocity
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $velocity000 = $velocitya
        $velocity100 = $velocity0
        $velocity010 = $velocityaa
        $velocity110 = $velocityab
        $velocity001 = $Fluid[(($c+{-1, 0, 1})%$Fluid.bounds)].velocity
        $velocity101 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity
        $velocity011 = $Fluid[(($c+{-1, 1, 1})%$Fluid.bounds)].velocity
        $velocity111 = $Fluid[(($c+{0, 1, 1})%$Fluid.bounds)].velocity
      else
        $velocity000 = $Fluid[(($c+{-1, 0, -1})%$Fluid.bounds)].velocity
        $velocity100 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].velocity
        $velocity010 = $Fluid[(($c+{-1, 1, -1})%$Fluid.bounds)].velocity
        $velocity110 = $Fluid[(($c+{0, 1, -1})%$Fluid.bounds)].velocity
        $velocity001 = $velocitya
        $velocity101 = $velocity0
        $velocity011 = $velocityaa
        $velocity111 = $velocityab
      end
    else
      var $velocityaa : double[3] = $Fluid[(($c+{-1, -1, 0})%$Fluid.bounds)].velocity
      var $velocityab : double[3] = $Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].velocity
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $velocity000 = $velocityaa
        $velocity100 = $velocityab
        $velocity010 = $velocitya
        $velocity110 = $velocity0
        $velocity001 = $Fluid[(($c+{-1, -1, 1})%$Fluid.bounds)].velocity
        $velocity101 = $Fluid[(($c+{0, -1, 1})%$Fluid.bounds)].velocity
        $velocity011 = $Fluid[(($c+{-1, 0, 1})%$Fluid.bounds)].velocity
        $velocity111 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].velocity
      else
        $velocity000 = $Fluid[(($c+{-1, -1, -1})%$Fluid.bounds)].velocity
        $velocity100 = $Fluid[(($c+{0, -1, -1})%$Fluid.bounds)].velocity
        $velocity010 = $Fluid[(($c+{-1, 0, -1})%$Fluid.bounds)].velocity
        $velocity110 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].velocity
        $velocity001 = $velocityaa
        $velocity101 = $velocityab
        $velocity011 = $velocitya
        $velocity111 = $velocity0
      end
    end
  end
  return TrilinearInterpolateVelocity($xyz, $velocity000, $velocity100, $velocity010, $velocity110, $velocity001, $velocity101, $velocity011, $velocity111, $Grid_xCellWidth, $Grid_xRealOrigin, $Grid_yCellWidth, $Grid_yRealOrigin, $Grid_zCellWidth, $Grid_zRealOrigin)
end

__demand(__inline)
task TrilinearInterpolateTemp($xyz : double[3], $c000 : double, $c100 : double, $c010 : double, $c110 : double, $c001 : double, $c101 : double, $c011 : double, $c111 : double, $Grid_xCellWidth : double, $Grid_xRealOrigin : double, $Grid_yCellWidth : double, $Grid_yRealOrigin : double, $Grid_zCellWidth : double, $Grid_zRealOrigin : double) : double
-- leaf (false), inner (false), idempotent (false)
  var $dX : double = fmod(((($xyz[int32(0)]-$Grid_xRealOrigin)/$Grid_xCellWidth)+double(0.5)), double(1))
  var $dY : double = fmod(((($xyz[int32(1)]-$Grid_yRealOrigin)/$Grid_yCellWidth)+double(0.5)), double(1))
  var $dZ : double = fmod(((($xyz[int32(2)]-$Grid_zRealOrigin)/$Grid_zCellWidth)+double(0.5)), double(1))
  var $oneMinusdX : double = (double(1)-$dX)
  var $oneMinusdY : double = (double(1)-$dY)
  var $oneMinusdZ : double = (double(1)-$dZ)
  var $weight00 : double = (($c000*$oneMinusdX)+($c100*$dX))
  var $weight10 : double = (($c010*$oneMinusdX)+($c110*$dX))
  var $weight01 : double = (($c001*$oneMinusdX)+($c101*$dX))
  var $weight11 : double = (($c011*$oneMinusdX)+($c111*$dX))
  var $weight0 : double = (($weight00*$oneMinusdY)+($weight10*$dY))
  var $weight1 : double = (($weight01*$oneMinusdY)+($weight11*$dY))
  return (($weight0*$oneMinusdZ)+($weight1*$dZ))
end

__demand(__inline)
task InterpolateTriTemp($c : int3d, $xyz : double[3], $Fluid : region(ispace(int3d), Fluid_columns), $Grid_xCellWidth : double, $Grid_xRealOrigin : double, $Grid_yCellWidth : double, $Grid_yRealOrigin : double, $Grid_zCellWidth : double, $Grid_zRealOrigin : double) : double
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.centerCoordinates), reads($Fluid.temperature)
do
  var $temp000 : double = double(double(0))
  var $temp100 : double = double(double(0))
  var $temp010 : double = double(double(0))
  var $temp110 : double = double(double(0))
  var $temp001 : double = double(double(0))
  var $temp101 : double = double(double(0))
  var $temp011 : double = double(double(0))
  var $temp111 : double = double(double(0))
  var $temp0 : double = $Fluid[$c].temperature
  if ($xyz[int32(0)]>$Fluid[$c].centerCoordinates[int32(0)]) then
    var $tempb : double = $Fluid[(($c+{1, 0, 0})%$Fluid.bounds)].temperature
    if ($xyz[int32(1)]>$Fluid[$c].centerCoordinates[int32(1)]) then
      var $tempaa : double = $Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].temperature
      var $tempab : double = $Fluid[(($c+{1, 1, 0})%$Fluid.bounds)].temperature
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $temp000 = $temp0
        $temp100 = $tempb
        $temp010 = $tempaa
        $temp110 = $tempab
        $temp001 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature
        $temp101 = $Fluid[(($c+{1, 0, 1})%$Fluid.bounds)].temperature
        $temp011 = $Fluid[(($c+{0, 1, 1})%$Fluid.bounds)].temperature
        $temp111 = $Fluid[(($c+{1, 1, 1})%$Fluid.bounds)].temperature
      else
        $temp000 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].temperature
        $temp100 = $Fluid[(($c+{1, 0, -1})%$Fluid.bounds)].temperature
        $temp010 = $Fluid[(($c+{0, 1, -1})%$Fluid.bounds)].temperature
        $temp110 = $Fluid[(($c+{1, 1, -1})%$Fluid.bounds)].temperature
        $temp001 = $temp0
        $temp101 = $tempb
        $temp011 = $tempaa
        $temp111 = $tempab
      end
    else
      var $tempaa : double = $Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].temperature
      var $tempab : double = $Fluid[(($c+{1, -1, 0})%$Fluid.bounds)].temperature
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $temp000 = $tempaa
        $temp100 = $tempab
        $temp010 = $temp0
        $temp110 = $tempb
        $temp001 = $Fluid[(($c+{0, -1, 1})%$Fluid.bounds)].temperature
        $temp101 = $Fluid[(($c+{1, -1, 1})%$Fluid.bounds)].temperature
        $temp011 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature
        $temp111 = $Fluid[(($c+{1, 0, 1})%$Fluid.bounds)].temperature
      else
        $temp000 = $Fluid[(($c+{0, -1, -1})%$Fluid.bounds)].temperature
        $temp100 = $Fluid[(($c+{1, -1, -1})%$Fluid.bounds)].temperature
        $temp010 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].temperature
        $temp110 = $Fluid[(($c+{1, 0, -1})%$Fluid.bounds)].temperature
        $temp001 = $tempaa
        $temp101 = $tempab
        $temp011 = $temp0
        $temp111 = $tempb
      end
    end
  else
    var $tempa : double = $Fluid[(($c+{-1, 0, 0})%$Fluid.bounds)].temperature
    if ($xyz[int32(1)]>$Fluid[$c].centerCoordinates[int32(1)]) then
      var $tempaa : double = $Fluid[(($c+{-1, 1, 0})%$Fluid.bounds)].temperature
      var $tempab : double = $Fluid[(($c+{0, 1, 0})%$Fluid.bounds)].temperature
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $temp000 = $tempa
        $temp100 = $temp0
        $temp010 = $tempaa
        $temp110 = $tempab
        $temp001 = $Fluid[(($c+{-1, 0, 1})%$Fluid.bounds)].temperature
        $temp101 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature
        $temp011 = $Fluid[(($c+{-1, 1, 1})%$Fluid.bounds)].temperature
        $temp111 = $Fluid[(($c+{0, 1, 1})%$Fluid.bounds)].temperature
      else
        $temp000 = $Fluid[(($c+{-1, 0, -1})%$Fluid.bounds)].temperature
        $temp100 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].temperature
        $temp010 = $Fluid[(($c+{-1, 1, -1})%$Fluid.bounds)].temperature
        $temp110 = $Fluid[(($c+{0, 1, -1})%$Fluid.bounds)].temperature
        $temp001 = $tempa
        $temp101 = $temp0
        $temp011 = $tempaa
        $temp111 = $tempab
      end
    else
      var $tempaa : double = $Fluid[(($c+{-1, -1, 0})%$Fluid.bounds)].temperature
      var $tempab : double = $Fluid[(($c+{0, -1, 0})%$Fluid.bounds)].temperature
      if ($xyz[int32(2)]>$Fluid[$c].centerCoordinates[int32(2)]) then
        $temp000 = $tempaa
        $temp100 = $tempab
        $temp010 = $tempa
        $temp110 = $temp0
        $temp001 = $Fluid[(($c+{-1, -1, 1})%$Fluid.bounds)].temperature
        $temp101 = $Fluid[(($c+{0, -1, 1})%$Fluid.bounds)].temperature
        $temp011 = $Fluid[(($c+{-1, 0, 1})%$Fluid.bounds)].temperature
        $temp111 = $Fluid[(($c+{0, 0, 1})%$Fluid.bounds)].temperature
      else
        $temp000 = $Fluid[(($c+{-1, -1, -1})%$Fluid.bounds)].temperature
        $temp100 = $Fluid[(($c+{0, -1, -1})%$Fluid.bounds)].temperature
        $temp010 = $Fluid[(($c+{-1, 0, -1})%$Fluid.bounds)].temperature
        $temp110 = $Fluid[(($c+{0, 0, -1})%$Fluid.bounds)].temperature
        $temp001 = $tempaa
        $temp101 = $tempab
        $temp011 = $tempa
        $temp111 = $temp0
      end
    end
  end
  return TrilinearInterpolateTemp($xyz, $temp000, $temp100, $temp010, $temp110, $temp001, $temp101, $temp011, $temp111, $Grid_xCellWidth, $Grid_xRealOrigin, $Grid_yCellWidth, $Grid_yRealOrigin, $Grid_zCellWidth, $Grid_zRealOrigin)
end

__demand(__parallel, __cuda)
task Particles_AddFlowCoupling($particles : region(ispace(int1d), particles_columns), $Fluid : region(ispace(int3d), Fluid_columns), $Flow_constantVisc : double, $Flow_powerlawTempRef : double, $Flow_powerlawViscRef : double, $Flow_sutherlandSRef : double, $Flow_sutherlandTempRef : double, $Flow_sutherlandViscRef : double, $Flow_viscosityModel___value : int32, $Grid_xCellWidth : double, $Grid_xRealOrigin : double, $Grid_yCellWidth : double, $Grid_yRealOrigin : double, $Grid_zCellWidth : double, $Grid_zRealOrigin : double, $Particles_convectiveCoeff : double, $Particles_heatCapacity : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.centerCoordinates), reads($Fluid.temperature), reads($Fluid.velocity), reads($particles.cell), reads($particles.deltaTemperatureTerm), writes($particles.deltaTemperatureTerm), reads($particles.deltaVelocityOverRelaxationTime), writes($particles.deltaVelocityOverRelaxationTime), reads($particles.density), reads($particles.diameter), reads($particles.position), reads($particles.position_t), writes($particles.position_t), reads($particles.temperature), reads($particles.temperature_t), writes($particles.temperature_t), reads($particles.velocity), reads($particles.velocity_t), writes($particles.velocity_t), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      var $flowVelocity : double[3] = InterpolateTriVelocity($particles[$p].cell, $particles[$p].position, $Fluid, $Grid_xCellWidth, $Grid_xRealOrigin, $Grid_yCellWidth, $Grid_yRealOrigin, $Grid_zCellWidth, $Grid_zRealOrigin)
      var $flowTemperature : double = InterpolateTriTemp($particles[$p].cell, $particles[$p].position, $Fluid, $Grid_xCellWidth, $Grid_xRealOrigin, $Grid_yCellWidth, $Grid_yRealOrigin, $Grid_zCellWidth, $Grid_zRealOrigin)
      var $flowDynamicViscosity : double = GetDynamicViscosity($flowTemperature, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value)
      var $tmp : double[3] = $particles[$p].velocity
      var $v : double[3] = $particles[$p].position_t
      $v[0] += $tmp[0]
      $v[1] += $tmp[1]
      $v[2] += $tmp[2]
      $particles[$p].position_t = $v
      var $particleReynoldsNumber : double = double(0)
      var $relaxationTime : double = ((($particles[$p].density*pow($particles[$p].diameter, double(int32(2))))/(double(18)*$flowDynamicViscosity))/(double(1)+(double(0.15)*pow($particleReynoldsNumber, double(0.687)))))
      $particles[$p].deltaVelocityOverRelaxationTime = vs_div_double_3(vv_sub_double_3($flowVelocity, $particles[$p].velocity), $relaxationTime)
      $particles[$p].deltaTemperatureTerm = (((double(3.1415926535898)*pow($particles[$p].diameter, double(int32(2))))*$Particles_convectiveCoeff)*($flowTemperature-$particles[$p].temperature))
      var $tmp#10496 : double[3] = $particles[$p].deltaVelocityOverRelaxationTime
      var $v#10497 : double[3] = $particles[$p].velocity_t
      $v#10497[0] += $tmp#10496[0]
      $v#10497[1] += $tmp#10496[1]
      $v#10497[2] += $tmp#10496[2]
      $particles[$p].velocity_t = $v#10497
      $particles[$p].temperature_t += ($particles[$p].deltaTemperatureTerm/((((double(3.1415926535898)*pow($particles[$p].diameter, double(int32(3))))/double(6))*$particles[$p].density)*$Particles_heatCapacity))
    else
    end
  end
end

__demand(__parallel, __cuda)
task Particles_AddBodyForces($particles : region(ispace(int1d), particles_columns), $Particles_bodyForce : double[3])
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.velocity_t), writes($particles.velocity_t), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      var $tmp : double[3] = $Particles_bodyForce
      var $v : double[3] = $particles[$p].velocity_t
      $v[0] += $tmp[0]
      $v[1] += $tmp[1]
      $v[2] += $tmp[2]
      $particles[$p].velocity_t = $v
    else
    end
  end
end

__demand(__parallel, __cuda)
task Radiation_ClearAccumulators($Radiation : region(ispace(int3d), Radiation_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($Radiation.acc_d2), writes($Radiation.acc_d2), reads($Radiation.acc_d2t4), writes($Radiation.acc_d2t4)
do
  __demand(__openmp)
  for $c : int3d(Radiation_columns, $Radiation) in $Radiation do
    $Radiation[$c].acc_d2 = double(0)
    $Radiation[$c].acc_d2t4 = double(0)
  end
end

__demand(__cuda)
task Radiation_AccumulateParticleValues($particles : region(ispace(int1d), particles_columns), $Fluid : region(ispace(int3d), Fluid_columns), $Radiation : region(ispace(int3d), Radiation_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.to_Radiation), reads($Radiation.acc_d2), writes($Radiation.acc_d2), reads($Radiation.acc_d2t4), writes($Radiation.acc_d2t4), reads($particles.cell), reads($particles.diameter), reads($particles.temperature), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $Radiation[$Fluid[$particles[$p].cell].to_Radiation].acc_d2 += pow($particles[$p].diameter, double(2))
      $Radiation[$Fluid[$particles[$p].cell].to_Radiation].acc_d2t4 += (pow($particles[$p].diameter, double(2))*pow($particles[$p].temperature, double(4)))
    else
    end
  end
end

__demand(__parallel, __cuda)
task Radiation_UpdateFieldValues($Radiation : region(ispace(int3d), Radiation_columns), $Radiation_cellVolume : double, $Radiation_qa : double, $Radiation_qs : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Radiation.Ib), writes($Radiation.Ib), reads($Radiation.acc_d2), reads($Radiation.acc_d2t4), reads($Radiation.sigma), writes($Radiation.sigma)
do
  __demand(__openmp)
  for $c : int3d(Radiation_columns, $Radiation) in $Radiation do
    $Radiation[$c].sigma = ((($Radiation[$c].acc_d2*double(3.1415926535898))*($Radiation_qa+$Radiation_qs))/(double(4)*$Radiation_cellVolume))
    if ($Radiation[$c].acc_d2==double(0)) then
      $Radiation[$c].Ib = double(0)
    else
      $Radiation[$c].Ib = ((double(5.67e-08)*$Radiation[$c].acc_d2t4)/(double(3.1415926535898)*$Radiation[$c].acc_d2))
    end
  end
end

__demand(__cuda)
task Particles_AbsorbRadiation($particles : region(ispace(int1d), particles_columns), $Fluid : region(ispace(int3d), Fluid_columns), $Radiation : region(ispace(int3d), Radiation_columns), $Particles_heatCapacity : double, $Radiation_qa : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.to_Radiation), reads($Radiation.G), reads($particles.cell), reads($particles.density), reads($particles.diameter), reads($particles.temperature), reads($particles.temperature_t), writes($particles.temperature_t), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      var $t4 : double = pow($particles[$p].temperature, double(4))
      var $alpha : double = ((((double(3.1415926535898)*$Radiation_qa)*pow($particles[$p].diameter, double(2)))*($Radiation[$Fluid[$particles[$p].cell].to_Radiation].G-((double(4)*double(5.67e-08))*$t4)))/double(4))
      $particles[$p].temperature_t += ($alpha/((((double(3.1415926535898)*pow($particles[$p].diameter, double(int32(3))))/double(6))*$particles[$p].density)*$Particles_heatCapacity))
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_AddParticlesCoupling($particles : region(ispace(int1d), particles_columns), $Fluid : region(ispace(int3d), Fluid_columns), $Grid_cellVolume : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rhoEnergy_t), writes($Fluid.rhoEnergy_t), reads($Fluid.rhoVelocity_t), writes($Fluid.rhoVelocity_t), reads($particles.cell), reads($particles.deltaTemperatureTerm), reads($particles.deltaVelocityOverRelaxationTime), reads($particles.density), reads($particles.diameter), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      var $tmp : double[3] = vs_div_double_3(vs_mul_double_3($particles[$p].deltaVelocityOverRelaxationTime, (-(((double(3.1415926535898)*pow($particles[$p].diameter, double(int32(3))))/double(6))*$particles[$p].density))), $Grid_cellVolume)
      var $v : double[3] = $Fluid[$particles[$p].cell].rhoVelocity_t
      $v[0] += $tmp[0]
      $v[1] += $tmp[1]
      $v[2] += $tmp[2]
      $Fluid[$particles[$p].cell].rhoVelocity_t = $v
      $Fluid[$particles[$p].cell].rhoEnergy_t += ((-$particles[$p].deltaTemperatureTerm)/$Grid_cellVolume)
    else
    end
  end
end

__demand(__parallel, __cuda)
task Flow_UpdateVars($Fluid : region(ispace(int3d), Fluid_columns), $Integrator_deltaTime : double, $Integrator_stage : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($Fluid.rho), writes($Fluid.rho), reads($Fluid.rhoEnergy), writes($Fluid.rhoEnergy), reads($Fluid.rhoEnergy_new), reads($Fluid.rhoEnergy_new), writes($Fluid.rhoEnergy_new), reads($Fluid.rhoEnergy_old), reads($Fluid.rhoEnergy_t), reads($Fluid.rhoVelocity), writes($Fluid.rhoVelocity), reads($Fluid.rhoVelocity_new), reads($Fluid.rhoVelocity_new), writes($Fluid.rhoVelocity_new), reads($Fluid.rhoVelocity_old), reads($Fluid.rhoVelocity_t), reads($Fluid.rho_new), reads($Fluid.rho_new), writes($Fluid.rho_new), reads($Fluid.rho_old), reads($Fluid.rho_t)
do
  __demand(__openmp)
  for $c : int3d(Fluid_columns, $Fluid) in $Fluid do
    var $deltaTime : double = $Integrator_deltaTime
    if ($Integrator_stage==int32(1)) then
      $Fluid[$c].rho_new += (((double(1)/double(6))*$deltaTime)*$Fluid[$c].rho_t)
      $Fluid[$c].rho = ($Fluid[$c].rho_old+((double(0.5)*$deltaTime)*$Fluid[$c].rho_t))
      var $tmp : double[3] = vs_mul_double_3($Fluid[$c].rhoVelocity_t, ((double(1)/double(6))*$deltaTime))
      var $v : double[3] = $Fluid[$c].rhoVelocity_new
      $v[0] += $tmp[0]
      $v[1] += $tmp[1]
      $v[2] += $tmp[2]
      $Fluid[$c].rhoVelocity_new = $v
      $Fluid[$c].rhoVelocity = vv_add_double_3($Fluid[$c].rhoVelocity_old, vs_mul_double_3($Fluid[$c].rhoVelocity_t, (double(0.5)*$deltaTime)))
      $Fluid[$c].rhoEnergy_new += (((double(1)/double(6))*$deltaTime)*$Fluid[$c].rhoEnergy_t)
      $Fluid[$c].rhoEnergy = ($Fluid[$c].rhoEnergy_old+((double(0.5)*$deltaTime)*$Fluid[$c].rhoEnergy_t))
    else
      if ($Integrator_stage==int32(2)) then
        $Fluid[$c].rho_new += (((double(1)/double(3))*$deltaTime)*$Fluid[$c].rho_t)
        $Fluid[$c].rho = ($Fluid[$c].rho_old+((double(0.5)*$deltaTime)*$Fluid[$c].rho_t))
        var $tmp : double[3] = vs_mul_double_3($Fluid[$c].rhoVelocity_t, ((double(1)/double(3))*$deltaTime))
        var $v : double[3] = $Fluid[$c].rhoVelocity_new
        $v[0] += $tmp[0]
        $v[1] += $tmp[1]
        $v[2] += $tmp[2]
        $Fluid[$c].rhoVelocity_new = $v
        $Fluid[$c].rhoVelocity = vv_add_double_3($Fluid[$c].rhoVelocity_old, vs_mul_double_3($Fluid[$c].rhoVelocity_t, (double(0.5)*$deltaTime)))
        $Fluid[$c].rhoEnergy_new += (((double(1)/double(3))*$deltaTime)*$Fluid[$c].rhoEnergy_t)
        $Fluid[$c].rhoEnergy = ($Fluid[$c].rhoEnergy_old+((double(0.5)*$deltaTime)*$Fluid[$c].rhoEnergy_t))
      else
        if ($Integrator_stage==int32(3)) then
          $Fluid[$c].rho_new += (((double(1)/double(3))*$deltaTime)*$Fluid[$c].rho_t)
          $Fluid[$c].rho = ($Fluid[$c].rho_old+((double(1)*$deltaTime)*$Fluid[$c].rho_t))
          var $tmp : double[3] = vs_mul_double_3($Fluid[$c].rhoVelocity_t, ((double(1)/double(3))*$deltaTime))
          var $v : double[3] = $Fluid[$c].rhoVelocity_new
          $v[0] += $tmp[0]
          $v[1] += $tmp[1]
          $v[2] += $tmp[2]
          $Fluid[$c].rhoVelocity_new = $v
          $Fluid[$c].rhoVelocity = vv_add_double_3($Fluid[$c].rhoVelocity_old, vs_mul_double_3($Fluid[$c].rhoVelocity_t, (double(1)*$deltaTime)))
          $Fluid[$c].rhoEnergy_new += (((double(1)/double(3))*$deltaTime)*$Fluid[$c].rhoEnergy_t)
          $Fluid[$c].rhoEnergy = ($Fluid[$c].rhoEnergy_old+((double(1)*$deltaTime)*$Fluid[$c].rhoEnergy_t))
        else
          $Fluid[$c].rho = ($Fluid[$c].rho_new+(((double(1)/double(6))*$deltaTime)*$Fluid[$c].rho_t))
          $Fluid[$c].rhoVelocity = vv_add_double_3($Fluid[$c].rhoVelocity_new, vs_mul_double_3($Fluid[$c].rhoVelocity_t, ((double(1)/double(6))*$deltaTime)))
          $Fluid[$c].rhoEnergy = ($Fluid[$c].rhoEnergy_new+(((double(1)/double(6))*$deltaTime)*$Fluid[$c].rhoEnergy_t))
        end
      end
    end
  end
end

__demand(__parallel, __cuda)
task Particles_UpdateVars($particles : region(ispace(int1d), particles_columns), $Integrator_deltaTime : double, $Integrator_stage : int32)
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.position), writes($particles.position), reads($particles.position_new), reads($particles.position_new), writes($particles.position_new), reads($particles.position_old), reads($particles.position_t), reads($particles.temperature), writes($particles.temperature), reads($particles.temperature_new), reads($particles.temperature_new), writes($particles.temperature_new), reads($particles.temperature_old), reads($particles.temperature_t), reads($particles.velocity), writes($particles.velocity), reads($particles.velocity_new), reads($particles.velocity_new), writes($particles.velocity_new), reads($particles.velocity_old), reads($particles.velocity_t), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      var $deltaTime : double = $Integrator_deltaTime
      if ($Integrator_stage==int32(1)) then
        var $tmp : double[3] = vs_mul_double_3($particles[$p].position_t, ((double(1)/double(6))*$deltaTime))
        var $v : double[3] = $particles[$p].position_new
        $v[0] += $tmp[0]
        $v[1] += $tmp[1]
        $v[2] += $tmp[2]
        $particles[$p].position_new = $v
        $particles[$p].position = vv_add_double_3($particles[$p].position_old, vs_mul_double_3($particles[$p].position_t, (double(0.5)*$deltaTime)))
        var $tmp#11020 : double[3] = vs_mul_double_3($particles[$p].velocity_t, ((double(1)/double(6))*$deltaTime))
        var $v#11021 : double[3] = $particles[$p].velocity_new
        $v#11021[0] += $tmp#11020[0]
        $v#11021[1] += $tmp#11020[1]
        $v#11021[2] += $tmp#11020[2]
        $particles[$p].velocity_new = $v#11021
        $particles[$p].velocity = vv_add_double_3($particles[$p].velocity_old, vs_mul_double_3($particles[$p].velocity_t, (double(0.5)*$deltaTime)))
        $particles[$p].temperature_new += (((double(1)/double(6))*$deltaTime)*$particles[$p].temperature_t)
        $particles[$p].temperature = ($particles[$p].temperature_old+((double(0.5)*$deltaTime)*$particles[$p].temperature_t))
      else
        if ($Integrator_stage==int32(2)) then
          var $tmp : double[3] = vs_mul_double_3($particles[$p].position_t, ((double(1)/double(3))*$deltaTime))
          var $v : double[3] = $particles[$p].position_new
          $v[0] += $tmp[0]
          $v[1] += $tmp[1]
          $v[2] += $tmp[2]
          $particles[$p].position_new = $v
          $particles[$p].position = vv_add_double_3($particles[$p].position_old, vs_mul_double_3($particles[$p].position_t, (double(0.5)*$deltaTime)))
          var $tmp#11024 : double[3] = vs_mul_double_3($particles[$p].velocity_t, ((double(1)/double(3))*$deltaTime))
          var $v#11025 : double[3] = $particles[$p].velocity_new
          $v#11025[0] += $tmp#11024[0]
          $v#11025[1] += $tmp#11024[1]
          $v#11025[2] += $tmp#11024[2]
          $particles[$p].velocity_new = $v#11025
          $particles[$p].velocity = vv_add_double_3($particles[$p].velocity_old, vs_mul_double_3($particles[$p].velocity_t, (double(0.5)*$deltaTime)))
          $particles[$p].temperature_new += (((double(1)/double(3))*$deltaTime)*$particles[$p].temperature_t)
          $particles[$p].temperature = ($particles[$p].temperature_old+((double(0.5)*$deltaTime)*$particles[$p].temperature_t))
        else
          if ($Integrator_stage==int32(3)) then
            var $tmp : double[3] = vs_mul_double_3($particles[$p].position_t, ((double(1)/double(3))*$deltaTime))
            var $v : double[3] = $particles[$p].position_new
            $v[0] += $tmp[0]
            $v[1] += $tmp[1]
            $v[2] += $tmp[2]
            $particles[$p].position_new = $v
            $particles[$p].position = vv_add_double_3($particles[$p].position_old, vs_mul_double_3($particles[$p].position_t, (double(1)*$deltaTime)))
            var $tmp#11028 : double[3] = vs_mul_double_3($particles[$p].velocity_t, ((double(1)/double(3))*$deltaTime))
            var $v#11029 : double[3] = $particles[$p].velocity_new
            $v#11029[0] += $tmp#11028[0]
            $v#11029[1] += $tmp#11028[1]
            $v#11029[2] += $tmp#11028[2]
            $particles[$p].velocity_new = $v#11029
            $particles[$p].velocity = vv_add_double_3($particles[$p].velocity_old, vs_mul_double_3($particles[$p].velocity_t, (double(1)*$deltaTime)))
            $particles[$p].temperature_new += (((double(1)/double(3))*$deltaTime)*$particles[$p].temperature_t)
            $particles[$p].temperature = ($particles[$p].temperature_old+((double(1)*$deltaTime)*$particles[$p].temperature_t))
          else
            $particles[$p].position = vv_add_double_3($particles[$p].position_new, vs_mul_double_3($particles[$p].position_t, ((double(1)/double(6))*$deltaTime)))
            $particles[$p].velocity = vv_add_double_3($particles[$p].velocity_new, vs_mul_double_3($particles[$p].velocity_t, ((double(1)/double(6))*$deltaTime)))
            $particles[$p].temperature = ($particles[$p].temperature_new+(((double(1)/double(6))*$deltaTime)*$particles[$p].temperature_t))
          end
        end
      end
    else
    end
  end
end

__demand(__parallel, __cuda)
task Particles_UpdateAuxiliaryStep1($particles : region(ispace(int1d), particles_columns), $BC_xBCLeftParticles : int32, $BC_xBCRightParticles : int32, $BC_yBCLeftParticles : int32, $BC_yBCRightParticles : int32, $BC_zBCLeftParticles : int32, $BC_zBCRightParticles : int32, $Grid_xOrigin : double, $Grid_xWidth : double, $Grid_yOrigin : double, $Grid_yWidth : double, $Grid_zOrigin : double, $Grid_zWidth : double, $Particles_restitutionCoeff : double)
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.position), reads($particles.position_ghost), writes($particles.position_ghost), reads($particles.velocity), reads($particles.velocity_ghost), writes($particles.velocity_ghost), reads($particles.velocity_ghost), writes($particles.velocity_ghost), reads($particles.velocity_t), reads($particles.velocity_t_ghost), writes($particles.velocity_t_ghost), reads($particles.velocity_t_ghost), writes($particles.velocity_t_ghost), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $particles[$p].position_ghost[int32(0)] = $particles[$p].position[int32(0)]
      $particles[$p].position_ghost[int32(1)] = $particles[$p].position[int32(1)]
      $particles[$p].position_ghost[int32(2)] = $particles[$p].position[int32(2)]
      $particles[$p].velocity_ghost[int32(0)] = $particles[$p].velocity[int32(0)]
      $particles[$p].velocity_ghost[int32(1)] = $particles[$p].velocity[int32(1)]
      $particles[$p].velocity_ghost[int32(2)] = $particles[$p].velocity[int32(2)]
      $particles[$p].velocity_t_ghost[int32(0)] = $particles[$p].velocity_t[int32(0)]
      $particles[$p].velocity_t_ghost[int32(1)] = $particles[$p].velocity_t[int32(1)]
      $particles[$p].velocity_t_ghost[int32(2)] = $particles[$p].velocity_t[int32(2)]
      if ($particles[$p].position[int32(0)]<$Grid_xOrigin) then
        if ($BC_xBCLeftParticles==int32(0)) then
          $particles[$p].position_ghost[int32(0)] = ($particles[$p].position[int32(0)]+$Grid_xWidth)
        else
          $particles[$p].position_ghost[int32(0)] = $Grid_xOrigin
          var $impulse : double = ((-(double(1)+$Particles_restitutionCoeff))*$particles[$p].velocity[int32(0)])
          if ($impulse<=double(int32(0))) then
            $particles[$p].velocity_ghost[int32(0)] += $impulse
          else
          end
          var $contact_force : double = (double(-1)*$particles[$p].velocity_t[int32(0)])
          if ($contact_force>double(int32(0))) then
            $particles[$p].velocity_t_ghost[int32(0)] += $contact_force
          else
          end
        end
      else
      end
      if ($particles[$p].position[int32(0)]>($Grid_xOrigin+$Grid_xWidth)) then
        if ($BC_xBCRightParticles==int32(0)) then
          $particles[$p].position_ghost[int32(0)] = ($particles[$p].position[int32(0)]-$Grid_xWidth)
        else
          $particles[$p].position_ghost[int32(0)] = ($Grid_xOrigin+$Grid_xWidth)
          var $impulse : double = ((-(double(1)+$Particles_restitutionCoeff))*$particles[$p].velocity[int32(0)])
          if ($impulse>=double(int32(0))) then
            $particles[$p].velocity_ghost[int32(0)] += $impulse
          else
          end
          var $contact_force : double = (double(-1)*$particles[$p].velocity_t[int32(0)])
          if ($contact_force<double(int32(0))) then
            $particles[$p].velocity_t_ghost[int32(0)] += $contact_force
          else
          end
        end
      else
      end
      if ($particles[$p].position[int32(1)]<$Grid_yOrigin) then
        if ($BC_yBCLeftParticles==int32(0)) then
          $particles[$p].position_ghost[int32(1)] = ($particles[$p].position[int32(1)]+$Grid_yWidth)
        else
          $particles[$p].position_ghost[int32(1)] = $Grid_yOrigin
          var $impulse : double = ((-(double(1)+$Particles_restitutionCoeff))*$particles[$p].velocity[int32(1)])
          if ($impulse<=double(int32(0))) then
            $particles[$p].velocity_ghost[int32(1)] += $impulse
          else
          end
          var $contact_force : double = (double(-1)*$particles[$p].velocity_t[int32(1)])
          if ($contact_force>double(int32(0))) then
            $particles[$p].velocity_t_ghost[int32(1)] += $contact_force
          else
          end
        end
      else
      end
      if ($particles[$p].position[int32(1)]>($Grid_yOrigin+$Grid_yWidth)) then
        if ($BC_yBCRightParticles==int32(0)) then
          $particles[$p].position_ghost[int32(1)] = ($particles[$p].position[int32(1)]-$Grid_yWidth)
        else
          $particles[$p].position_ghost[int32(1)] = ($Grid_yOrigin+$Grid_yWidth)
          var $impulse : double = ((-(double(1)+$Particles_restitutionCoeff))*$particles[$p].velocity[int32(1)])
          if ($impulse>=double(int32(0))) then
            $particles[$p].velocity_ghost[int32(1)] += $impulse
          else
          end
          var $contact_force : double = (double(-1)*$particles[$p].velocity_t[int32(1)])
          if ($contact_force<double(int32(0))) then
            $particles[$p].velocity_t_ghost[int32(1)] += $contact_force
          else
          end
        end
      else
      end
      if ($particles[$p].position[int32(2)]<$Grid_zOrigin) then
        if ($BC_zBCLeftParticles==int32(0)) then
          $particles[$p].position_ghost[int32(2)] = ($particles[$p].position[int32(2)]+$Grid_zWidth)
        else
          $particles[$p].position_ghost[int32(2)] = $Grid_zOrigin
          var $impulse : double = ((-(double(1)+$Particles_restitutionCoeff))*$particles[$p].velocity[int32(2)])
          if ($impulse<=double(int32(0))) then
            $particles[$p].velocity_ghost[int32(2)] += $impulse
          else
          end
          var $contact_force : double = (double(-1)*$particles[$p].velocity_t[int32(2)])
          if ($contact_force>double(int32(0))) then
            $particles[$p].velocity_t_ghost[int32(2)] += $contact_force
          else
          end
        end
      else
      end
      if ($particles[$p].position[int32(2)]>($Grid_zOrigin+$Grid_zWidth)) then
        if ($BC_zBCRightParticles==int32(0)) then
          $particles[$p].position_ghost[int32(2)] = ($particles[$p].position[int32(2)]-$Grid_zWidth)
        else
          $particles[$p].position_ghost[int32(2)] = ($Grid_zOrigin+$Grid_zWidth)
          var $impulse : double = ((-(double(1)+$Particles_restitutionCoeff))*$particles[$p].velocity[int32(2)])
          if ($impulse>=double(int32(0))) then
            $particles[$p].velocity_ghost[int32(2)] += $impulse
          else
          end
          var $contact_force : double = (double(-1)*$particles[$p].velocity_t[int32(2)])
          if ($contact_force<double(int32(0))) then
            $particles[$p].velocity_t_ghost[int32(2)] += $contact_force
          else
          end
        end
      else
      end
    else
    end
  end
end

__demand(__parallel, __cuda)
task Particles_UpdateAuxiliaryStep2($particles : region(ispace(int1d), particles_columns))
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.position), writes($particles.position), reads($particles.position_ghost), reads($particles.velocity), writes($particles.velocity), reads($particles.velocity_ghost), reads($particles.velocity_t), writes($particles.velocity_t), reads($particles.velocity_t_ghost), reads($particles.__valid)
do
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      $particles[$p].position = $particles[$p].position_ghost
      $particles[$p].velocity = $particles[$p].velocity_ghost
      $particles[$p].velocity_t = $particles[$p].velocity_t_ghost
    else
    end
  end
end

task Particles_DeleteEscapingParticles($particles : region(ispace(int1d), particles_columns), $Grid_xRealOrigin : double, $Grid_xRealWidth : double, $Grid_yRealOrigin : double, $Grid_yRealWidth : double, $Grid_zRealOrigin : double, $Grid_zRealWidth : double) : int64
-- leaf (false), inner (false), idempotent (false)
where
  reads($particles.position), reads($particles.__valid), writes($particles.__valid), reads($particles.__valid)
do
  var $acc : int64 = int64(0)
  __demand(__openmp)
  for $p : int1d(particles_columns, $particles) in $particles do
    if $particles[$p].__valid then
      var $min_x : double = $Grid_xRealOrigin
      var $max_x : double = ($Grid_xRealOrigin+$Grid_xRealWidth)
      var $min_y : double = $Grid_yRealOrigin
      var $max_y : double = ($Grid_yRealOrigin+$Grid_yRealWidth)
      var $min_z : double = $Grid_zRealOrigin
      var $max_z : double = ($Grid_zRealOrigin+$Grid_zRealWidth)
      var $pos : double[3] = $particles[$p].position
      if (((((($pos[int32(0)]>$max_x) or ($pos[int32(0)]<$min_x)) or ($pos[int32(1)]>$max_y)) or ($pos[int32(1)]<$min_y)) or ($pos[int32(2)]>$max_z)) or ($pos[int32(2)]<$min_z)) then
        $particles[$p].__valid = false
        $acc += (-int64(int32(1)))
      else
      end
    else
    end
  end
  return $acc
end

Fluid_dump_rho_pressure_velocity_ = HDF.mkDump(int3d, int3d, Fluid_columns, {"rho","pressure","velocity"})
particles_dump_cell_position_velocity_temperature_diameter___valid_ = HDF.mkDump(int1d, int3d, particles_columns, {"cell","position","velocity","temperature","diameter","__valid"})
__forbid(__optimize)
task work($config : Config)
-- leaf (false), inner (false), idempotent (false)
  var $NX : int32 = $config.Grid.xTiles
  var $NY : int32 = $config.Grid.yTiles
  var $NZ : int32 = $config.Grid.zTiles
  var $ZERO : double = double(int32(0))
  var $ONE : double = double(int32(1))
  var $Grid_xNum : int32 = $config.Grid.xNum
  var $Grid_yNum : int32 = $config.Grid.yNum
  var $Grid_zNum : int32 = $config.Grid.zNum
  var $Grid_xOrigin : double = $config.Grid.origin[0]
  var $Grid_yOrigin : double = $config.Grid.origin[1]
  var $Grid_zOrigin : double = $config.Grid.origin[2]
  var $Grid_xWidth : double = $config.Grid.xWidth
  var $Grid_yWidth : double = $config.Grid.yWidth
  var $Grid_zWidth : double = $config.Grid.zWidth
  var $Grid_xCellWidth : double = ($Grid_xWidth/$Grid_xNum)
  var $Grid_yCellWidth : double = ($Grid_yWidth/$Grid_yNum)
  var $Grid_zCellWidth : double = ($Grid_zWidth/$Grid_zNum)
  var $Grid_cellVolume : double = (($Grid_xCellWidth*$Grid_yCellWidth)*$Grid_zCellWidth)
  var $Grid_dXYZInverseSquare : double = (((((int32(1)/$Grid_xCellWidth)*int32(1))/$Grid_xCellWidth)+(((int32(1)/$Grid_yCellWidth)*int32(1))/$Grid_yCellWidth))+(((int32(1)/$Grid_zCellWidth)*int32(1))/$Grid_zCellWidth))
  var $BC_xBCPeriodic : bool = ($config.BC.xBCLeft.__value==int32(0))
  var $BC_xSign : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_xPosVelocity : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_xNegVelocity : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_xPosTemperature : double = double(int32(0))
  var $BC_xNegTemperature : double = double(int32(0))
  var $BC_yBCPeriodic : bool = ($config.BC.yBCLeft.__value==int32(0))
  var $BC_ySign : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_yPosVelocity : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_yNegVelocity : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_yPosTemperature : double = double(int32(0))
  var $BC_yNegTemperature : double = double(int32(0))
  var $BC_zBCPeriodic : bool = ($config.BC.zBCLeft.__value==int32(0))
  var $BC_zSign : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_zPosVelocity : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_zNegVelocity : double[3] = array(double(0.1), double(0.1), double(0.1))
  var $BC_zPosTemperature : double = double(int32(0))
  var $BC_zNegTemperature : double = double(int32(0))
  var $BC_xBCLeftParticles : int32 = int32(-1)
  var $BC_xBCRightParticles : int32 = int32(-1)
  var $BC_yBCLeftParticles : int32 = int32(-1)
  var $BC_yBCRightParticles : int32 = int32(-1)
  var $BC_zBCLeftParticles : int32 = int32(-1)
  var $BC_zBCRightParticles : int32 = int32(-1)
  var $Grid_xBnum : int32 = min(int32(1), (($config.BC.xBCLeft.__value-int32(0))*($config.BC.xBCLeft.__value-int32(0))))
  var $Grid_yBnum : int32 = min(int32(1), (($config.BC.yBCLeft.__value-int32(0))*($config.BC.yBCLeft.__value-int32(0))))
  var $Grid_zBnum : int32 = min(int32(1), (($config.BC.zBCLeft.__value-int32(0))*($config.BC.zBCLeft.__value-int32(0))))
  var $Grid_xRealOrigin : double = ($Grid_xOrigin-($Grid_xCellWidth*$Grid_xBnum))
  var $Grid_yRealOrigin : double = ($Grid_yOrigin-($Grid_yCellWidth*$Grid_yBnum))
  var $Grid_zRealOrigin : double = ($Grid_zOrigin-($Grid_zCellWidth*$Grid_zBnum))
  var $Grid_xRealWidth : double = ($Grid_xWidth+(int32(2)*($Grid_xCellWidth*$Grid_xBnum)))
  var $Grid_yRealWidth : double = ($Grid_yWidth+(int32(2)*($Grid_yCellWidth*$Grid_yBnum)))
  var $Grid_zRealWidth : double = ($Grid_zWidth+(int32(2)*($Grid_zCellWidth*$Grid_zBnum)))
  var $Integrator_simTime : double = double(int32(0))
  var $Integrator_time_old : double = double(int32(0))
  var $Integrator_timeStep : int32 = int32(0)
  var $Integrator_deltaTime : double = double(0.0001)
  var $Integrator_stage : int32 = int32(0)
  var $Integrator_maxConvectiveSpectralRadius : double = double(int32(0))
  var $Integrator_maxViscousSpectralRadius : double = double(int32(0))
  var $Integrator_maxHeatConductionSpectralRadius : double = double(int32(0))
  var $Flow_gasConstant : double = $config.Flow.gasConstant
  var $Flow_gamma : double = $config.Flow.gamma
  var $Flow_prandtl : double = $config.Flow.prandtl
  var $Flow_viscosityModel___value : int32 = $config.Flow.viscosityModel.__value
  var $Flow_constantVisc : double = $config.Flow.constantVisc
  var $Flow_powerlawViscRef : double = $config.Flow.powerlawViscRef
  var $Flow_powerlawTempRef : double = $config.Flow.powerlawTempRef
  var $Flow_sutherlandViscRef : double = $config.Flow.sutherlandViscRef
  var $Flow_sutherlandTempRef : double = $config.Flow.sutherlandTempRef
  var $Flow_sutherlandSRef : double = $config.Flow.sutherlandSRef
  var $Flow_initParams : double[5] = $config.Flow.initParams
  var $Flow_bodyForce : double[3] = $config.Flow.bodyForce
  var $Flow_averagePressure : double = double(int32(0))
  var $Flow_averageTemperature : double = double(int32(0))
  var $Flow_averageKineticEnergy : double = double(int32(0))
  var $Flow_minTemperature : double = double(int32(0))
  var $Flow_maxTemperature : double = double(int32(0))
  var $Flow_averagePD : double = double(int32(0))
  var $Flow_averageDissipation : double = double(int32(0))
  var $Flow_averageFe : double = double(int32(0))
  var $Flow_averageK : double = double(int32(0))
  var $Particles_maxNum : int32 = $config.Particles.maxNum
  var $Particles_restitutionCoeff : double = $config.Particles.restitutionCoeff
  var $Particles_convectiveCoeff : double = $config.Particles.convectiveCoeff
  var $Particles_heatCapacity : double = $config.Particles.heatCapacity
  var $Particles_density : double = $config.Particles.density
  var $Particles_bodyForce : double[3] = $config.Particles.bodyForce
  var $Particles_maxSkew : double = $config.Particles.maxSkew
  var $Particles_maxXferNum : int32 = $config.Particles.maxXferNum
  var $Particles_averageTemperature : double = double(int32(0))
  var $Particles_number : int64 = int64(int32(0))
  var $Radiation_qa : double = $config.Radiation.qa
  var $Radiation_qs : double = $config.Radiation.qs
  var $Radiation_xNum : int32 = $config.Radiation.xNum
  var $Radiation_yNum : int32 = $config.Radiation.yNum
  var $Radiation_zNum : int32 = $config.Radiation.zNum
  var $Radiation_xBnum : int32 = int32(0)
  var $Radiation_yBnum : int32 = int32(0)
  var $Radiation_zBnum : int32 = int32(0)
  var $Radiation_xPeriodic : bool = false
  var $Radiation_yPeriodic : bool = false
  var $Radiation_zPeriodic : bool = false
  var $Radiation_xCellWidth : double = ($Grid_xWidth/$Radiation_xNum)
  var $Radiation_yCellWidth : double = ($Grid_yWidth/$Radiation_yNum)
  var $Radiation_zCellWidth : double = ($Grid_zWidth/$Radiation_zNum)
  var $Radiation_cellVolume : double = (($Radiation_xCellWidth*$Radiation_yCellWidth)*$Radiation_zCellWidth)
  var $is : ispace(int3d) = ispace(int3d, int3d({x = ($Grid_xNum+(2*$Grid_xBnum)), y = ($Grid_yNum+(2*$Grid_yBnum)), z = ($Grid_zNum+(2*$Grid_zBnum))}))
  var $Fluid : region(ispace(int3d), Fluid_columns) = region($is, Fluid_columns)
  var $Fluid_copy : region(ispace(int3d), Fluid_columns) = region($is, Fluid_columns)
  var $is#11726 : ispace(int1d) = ispace(int1d, int1d((ceil((($Particles_maxNum/(($NX*$NY)*$NZ))*$Particles_maxSkew))*(($NX*$NY)*$NZ))))
  var $particles : region(ispace(int1d), particles_columns) = region($is#11726, particles_columns)
  var $particles_copy : region(ispace(int1d), particles_columns) = region($is#11726, particles_columns)
  var $is#11729 : ispace(int3d) = ispace(int3d, int3d({x = ($Radiation_xNum+(2*$Radiation_xBnum)), y = ($Radiation_yNum+(2*$Radiation_yBnum)), z = ($Radiation_zNum+(2*$Radiation_zBnum))}))
  var $Radiation : region(ispace(int3d), Radiation_columns) = region($is#11729, Radiation_columns)
  var $Radiation_copy : region(ispace(int3d), Radiation_columns) = region($is#11729, Radiation_columns)
  var $primColors : ispace(int3d) = ispace(int3d, int3d({$NX, $NY, $NZ}))
  base.assert((($Grid_xNum%$NX)==0), "Uneven partitioning")
  base.assert((($Grid_yNum%$NY)==0), "Uneven partitioning")
  base.assert((($Grid_zNum%$NZ)==0), "Uneven partitioning")
  var $coloring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $c : int3d($primColors) in $primColors do
    var $rect : rect3d = rect3d({lo = int3d({x = ($Grid_xBnum+(($Grid_xNum/$NX)*$c.x)), y = ($Grid_yBnum+(($Grid_yNum/$NY)*$c.y)), z = ($Grid_zBnum+(($Grid_zNum/$NZ)*$c.z))}), hi = int3d({x = (($Grid_xBnum+(($Grid_xNum/$NX)*($c.x+1)))-1), y = (($Grid_yBnum+(($Grid_yNum/$NY)*($c.y+1)))-1), z = (($Grid_zBnum+(($Grid_zNum/$NZ)*($c.z+1)))-1)})})
    if ($c.x==0) then
      $rect.lo.x -= $Grid_xBnum
    else
    end
    if ($c.x==($NX-1)) then
      $rect.hi.x += $Grid_xBnum
    else
    end
    if ($c.y==0) then
      $rect.lo.y -= $Grid_yBnum
    else
    end
    if ($c.y==($NY-1)) then
      $rect.hi.y += $Grid_yBnum
    else
    end
    if ($c.z==0) then
      $rect.lo.z -= $Grid_zBnum
    else
    end
    if ($c.z==($NZ-1)) then
      $rect.hi.z += $Grid_zBnum
    else
    end
    legion_domain_point_coloring_color_domain($coloring, legion_domain_point_t($c), legion_domain_t($rect))
  end
  var $Fluid_primPart : partition(disjoint, $Fluid, $primColors) = partition(disjoint, $Fluid, $coloring, $primColors)
  var $Fluid_copy_primPart : partition(disjoint, $Fluid_copy, $primColors) = partition(disjoint, $Fluid_copy, $coloring, $primColors)
  legion_domain_point_coloring_destroy($coloring)
  base.assert((($Particles_maxNum%(($NX*$NY)*$NZ))==0), "Uneven partitioning")
  var $coloring#11738 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $rBase : int64
        for $rStart : int1d(particles_columns, $particles) in $particles do
          $rBase = int64(($rStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*ceil((($Particles_maxNum/(($NX*$NY)*$NZ))*$Particles_maxSkew)))))
          break
        end
        legion_domain_point_coloring_color_domain($coloring#11738, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$rBase, (($rBase+ceil((($Particles_maxNum/(($NX*$NY)*$NZ))*$Particles_maxSkew)))-1)})))
      end
    end
  end
  var $particles_primPart : partition(disjoint, $particles, $primColors) = partition(disjoint, $particles, $coloring#11738, $primColors)
  var $particles_copy_primPart : partition(disjoint, $particles_copy, $primColors) = partition(disjoint, $particles_copy, $coloring#11738, $primColors)
  legion_domain_point_coloring_destroy($coloring#11738)
  var $particles_queue_0 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_0) in $particles_queue_0 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_0 : partition(disjoint, $particles_queue_0, $primColors) = partition(disjoint, $particles_queue_0, $srcColoring, $primColors)
  legion_domain_point_coloring_destroy($srcColoring)
  var $dstColoring : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff : int3d = int3d({0, 0, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $12929) in $particles_qSrcPart_0[((($c-$colorOff)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_0 : partition(aliased, $particles_queue_0, $primColors) = partition(aliased, $particles_queue_0, $dstColoring, $primColors)
  legion_domain_point_coloring_destroy($dstColoring)
  var $particles_queue_1 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11761 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_1) in $particles_queue_1 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11761, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_1 : partition(disjoint, $particles_queue_1, $primColors) = partition(disjoint, $particles_queue_1, $srcColoring#11761, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11761)
  var $dstColoring#11768 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11769 : int3d = int3d({0, 0, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $12943) in $particles_qSrcPart_1[((($c-$colorOff#11769)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11768, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_1 : partition(aliased, $particles_queue_1, $primColors) = partition(aliased, $particles_queue_1, $dstColoring#11768, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11768)
  var $particles_queue_2 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11775 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_2) in $particles_queue_2 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11775, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_2 : partition(disjoint, $particles_queue_2, $primColors) = partition(disjoint, $particles_queue_2, $srcColoring#11775, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11775)
  var $dstColoring#11782 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11783 : int3d = int3d({0, 1, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $12957) in $particles_qSrcPart_2[((($c-$colorOff#11783)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11782, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_2 : partition(aliased, $particles_queue_2, $primColors) = partition(aliased, $particles_queue_2, $dstColoring#11782, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11782)
  var $particles_queue_3 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11789 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_3) in $particles_queue_3 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11789, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_3 : partition(disjoint, $particles_queue_3, $primColors) = partition(disjoint, $particles_queue_3, $srcColoring#11789, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11789)
  var $dstColoring#11796 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11797 : int3d = int3d({0, 1, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $12971) in $particles_qSrcPart_3[((($c-$colorOff#11797)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11796, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_3 : partition(aliased, $particles_queue_3, $primColors) = partition(aliased, $particles_queue_3, $dstColoring#11796, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11796)
  var $particles_queue_4 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11803 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_4) in $particles_queue_4 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11803, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_4 : partition(disjoint, $particles_queue_4, $primColors) = partition(disjoint, $particles_queue_4, $srcColoring#11803, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11803)
  var $dstColoring#11810 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11811 : int3d = int3d({0, 1, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $12985) in $particles_qSrcPart_4[((($c-$colorOff#11811)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11810, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_4 : partition(aliased, $particles_queue_4, $primColors) = partition(aliased, $particles_queue_4, $dstColoring#11810, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11810)
  var $particles_queue_5 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11817 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_5) in $particles_queue_5 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11817, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_5 : partition(disjoint, $particles_queue_5, $primColors) = partition(disjoint, $particles_queue_5, $srcColoring#11817, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11817)
  var $dstColoring#11824 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11825 : int3d = int3d({0, -1, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $12999) in $particles_qSrcPart_5[((($c-$colorOff#11825)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11824, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_5 : partition(aliased, $particles_queue_5, $primColors) = partition(aliased, $particles_queue_5, $dstColoring#11824, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11824)
  var $particles_queue_6 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11831 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_6) in $particles_queue_6 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11831, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_6 : partition(disjoint, $particles_queue_6, $primColors) = partition(disjoint, $particles_queue_6, $srcColoring#11831, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11831)
  var $dstColoring#11838 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11839 : int3d = int3d({0, -1, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13013) in $particles_qSrcPart_6[((($c-$colorOff#11839)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11838, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_6 : partition(aliased, $particles_queue_6, $primColors) = partition(aliased, $particles_queue_6, $dstColoring#11838, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11838)
  var $particles_queue_7 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11845 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_7) in $particles_queue_7 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11845, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_7 : partition(disjoint, $particles_queue_7, $primColors) = partition(disjoint, $particles_queue_7, $srcColoring#11845, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11845)
  var $dstColoring#11852 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11853 : int3d = int3d({0, -1, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13027) in $particles_qSrcPart_7[((($c-$colorOff#11853)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11852, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_7 : partition(aliased, $particles_queue_7, $primColors) = partition(aliased, $particles_queue_7, $dstColoring#11852, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11852)
  var $particles_queue_8 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11859 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_8) in $particles_queue_8 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11859, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_8 : partition(disjoint, $particles_queue_8, $primColors) = partition(disjoint, $particles_queue_8, $srcColoring#11859, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11859)
  var $dstColoring#11866 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11867 : int3d = int3d({1, 0, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13041) in $particles_qSrcPart_8[((($c-$colorOff#11867)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11866, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_8 : partition(aliased, $particles_queue_8, $primColors) = partition(aliased, $particles_queue_8, $dstColoring#11866, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11866)
  var $particles_queue_9 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11873 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_9) in $particles_queue_9 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11873, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_9 : partition(disjoint, $particles_queue_9, $primColors) = partition(disjoint, $particles_queue_9, $srcColoring#11873, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11873)
  var $dstColoring#11880 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11881 : int3d = int3d({1, 0, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13055) in $particles_qSrcPart_9[((($c-$colorOff#11881)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11880, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_9 : partition(aliased, $particles_queue_9, $primColors) = partition(aliased, $particles_queue_9, $dstColoring#11880, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11880)
  var $particles_queue_10 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11887 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_10) in $particles_queue_10 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11887, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_10 : partition(disjoint, $particles_queue_10, $primColors) = partition(disjoint, $particles_queue_10, $srcColoring#11887, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11887)
  var $dstColoring#11894 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11895 : int3d = int3d({1, 0, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13069) in $particles_qSrcPart_10[((($c-$colorOff#11895)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11894, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_10 : partition(aliased, $particles_queue_10, $primColors) = partition(aliased, $particles_queue_10, $dstColoring#11894, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11894)
  var $particles_queue_11 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11901 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_11) in $particles_queue_11 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11901, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_11 : partition(disjoint, $particles_queue_11, $primColors) = partition(disjoint, $particles_queue_11, $srcColoring#11901, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11901)
  var $dstColoring#11908 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11909 : int3d = int3d({1, 1, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13083) in $particles_qSrcPart_11[((($c-$colorOff#11909)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11908, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_11 : partition(aliased, $particles_queue_11, $primColors) = partition(aliased, $particles_queue_11, $dstColoring#11908, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11908)
  var $particles_queue_12 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11915 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_12) in $particles_queue_12 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11915, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_12 : partition(disjoint, $particles_queue_12, $primColors) = partition(disjoint, $particles_queue_12, $srcColoring#11915, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11915)
  var $dstColoring#11922 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11923 : int3d = int3d({1, 1, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13097) in $particles_qSrcPart_12[((($c-$colorOff#11923)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11922, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_12 : partition(aliased, $particles_queue_12, $primColors) = partition(aliased, $particles_queue_12, $dstColoring#11922, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11922)
  var $particles_queue_13 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11929 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_13) in $particles_queue_13 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11929, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_13 : partition(disjoint, $particles_queue_13, $primColors) = partition(disjoint, $particles_queue_13, $srcColoring#11929, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11929)
  var $dstColoring#11936 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11937 : int3d = int3d({1, 1, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13111) in $particles_qSrcPart_13[((($c-$colorOff#11937)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11936, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_13 : partition(aliased, $particles_queue_13, $primColors) = partition(aliased, $particles_queue_13, $dstColoring#11936, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11936)
  var $particles_queue_14 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11943 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_14) in $particles_queue_14 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11943, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_14 : partition(disjoint, $particles_queue_14, $primColors) = partition(disjoint, $particles_queue_14, $srcColoring#11943, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11943)
  var $dstColoring#11950 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11951 : int3d = int3d({1, -1, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13125) in $particles_qSrcPart_14[((($c-$colorOff#11951)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11950, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_14 : partition(aliased, $particles_queue_14, $primColors) = partition(aliased, $particles_queue_14, $dstColoring#11950, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11950)
  var $particles_queue_15 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11957 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_15) in $particles_queue_15 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11957, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_15 : partition(disjoint, $particles_queue_15, $primColors) = partition(disjoint, $particles_queue_15, $srcColoring#11957, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11957)
  var $dstColoring#11964 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11965 : int3d = int3d({1, -1, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13139) in $particles_qSrcPart_15[((($c-$colorOff#11965)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11964, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_15 : partition(aliased, $particles_queue_15, $primColors) = partition(aliased, $particles_queue_15, $dstColoring#11964, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11964)
  var $particles_queue_16 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11971 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_16) in $particles_queue_16 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11971, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_16 : partition(disjoint, $particles_queue_16, $primColors) = partition(disjoint, $particles_queue_16, $srcColoring#11971, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11971)
  var $dstColoring#11978 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11979 : int3d = int3d({1, -1, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13153) in $particles_qSrcPart_16[((($c-$colorOff#11979)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11978, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_16 : partition(aliased, $particles_queue_16, $primColors) = partition(aliased, $particles_queue_16, $dstColoring#11978, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11978)
  var $particles_queue_17 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11985 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_17) in $particles_queue_17 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11985, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_17 : partition(disjoint, $particles_queue_17, $primColors) = partition(disjoint, $particles_queue_17, $srcColoring#11985, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11985)
  var $dstColoring#11992 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#11993 : int3d = int3d({-1, 0, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13167) in $particles_qSrcPart_17[((($c-$colorOff#11993)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#11992, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_17 : partition(aliased, $particles_queue_17, $primColors) = partition(aliased, $particles_queue_17, $dstColoring#11992, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#11992)
  var $particles_queue_18 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#11999 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_18) in $particles_queue_18 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#11999, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_18 : partition(disjoint, $particles_queue_18, $primColors) = partition(disjoint, $particles_queue_18, $srcColoring#11999, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#11999)
  var $dstColoring#12006 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12007 : int3d = int3d({-1, 0, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13181) in $particles_qSrcPart_18[((($c-$colorOff#12007)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12006, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_18 : partition(aliased, $particles_queue_18, $primColors) = partition(aliased, $particles_queue_18, $dstColoring#12006, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12006)
  var $particles_queue_19 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#12013 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_19) in $particles_queue_19 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#12013, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_19 : partition(disjoint, $particles_queue_19, $primColors) = partition(disjoint, $particles_queue_19, $srcColoring#12013, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#12013)
  var $dstColoring#12020 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12021 : int3d = int3d({-1, 0, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13195) in $particles_qSrcPart_19[((($c-$colorOff#12021)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12020, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_19 : partition(aliased, $particles_queue_19, $primColors) = partition(aliased, $particles_queue_19, $dstColoring#12020, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12020)
  var $particles_queue_20 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#12027 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_20) in $particles_queue_20 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#12027, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_20 : partition(disjoint, $particles_queue_20, $primColors) = partition(disjoint, $particles_queue_20, $srcColoring#12027, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#12027)
  var $dstColoring#12034 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12035 : int3d = int3d({-1, 1, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13209) in $particles_qSrcPart_20[((($c-$colorOff#12035)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12034, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_20 : partition(aliased, $particles_queue_20, $primColors) = partition(aliased, $particles_queue_20, $dstColoring#12034, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12034)
  var $particles_queue_21 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#12041 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_21) in $particles_queue_21 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#12041, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_21 : partition(disjoint, $particles_queue_21, $primColors) = partition(disjoint, $particles_queue_21, $srcColoring#12041, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#12041)
  var $dstColoring#12048 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12049 : int3d = int3d({-1, 1, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13223) in $particles_qSrcPart_21[((($c-$colorOff#12049)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12048, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_21 : partition(aliased, $particles_queue_21, $primColors) = partition(aliased, $particles_queue_21, $dstColoring#12048, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12048)
  var $particles_queue_22 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#12055 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_22) in $particles_queue_22 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#12055, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_22 : partition(disjoint, $particles_queue_22, $primColors) = partition(disjoint, $particles_queue_22, $srcColoring#12055, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#12055)
  var $dstColoring#12062 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12063 : int3d = int3d({-1, 1, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13237) in $particles_qSrcPart_22[((($c-$colorOff#12063)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12062, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_22 : partition(aliased, $particles_queue_22, $primColors) = partition(aliased, $particles_queue_22, $dstColoring#12062, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12062)
  var $particles_queue_23 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#12069 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_23) in $particles_queue_23 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#12069, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_23 : partition(disjoint, $particles_queue_23, $primColors) = partition(disjoint, $particles_queue_23, $srcColoring#12069, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#12069)
  var $dstColoring#12076 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12077 : int3d = int3d({-1, -1, 0})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13251) in $particles_qSrcPart_23[((($c-$colorOff#12077)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12076, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_23 : partition(aliased, $particles_queue_23, $primColors) = partition(aliased, $particles_queue_23, $dstColoring#12076, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12076)
  var $particles_queue_24 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#12083 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_24) in $particles_queue_24 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#12083, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_24 : partition(disjoint, $particles_queue_24, $primColors) = partition(disjoint, $particles_queue_24, $srcColoring#12083, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#12083)
  var $dstColoring#12090 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12091 : int3d = int3d({-1, -1, 1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13265) in $particles_qSrcPart_24[((($c-$colorOff#12091)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12090, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_24 : partition(aliased, $particles_queue_24, $primColors) = partition(aliased, $particles_queue_24, $dstColoring#12090, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12090)
  var $particles_queue_25 : region(ispace(int1d), int8[376]) = region(ispace(int1d, int1d(($Particles_maxXferNum*(($NX*$NY)*$NZ)))), int8[376])
  var $srcColoring#12097 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $z : int32 = 0, $NZ do
    for $y : int32 = 0, $NY do
      for $x : int32 = 0, $NX do
        var $qBase : int64
        for $qStart : int1d(int8[376], $particles_queue_25) in $particles_queue_25 do
          $qBase = int64(($qStart+((((($z*$NX)*$NY)+($y*$NX))+$x)*$Particles_maxXferNum)))
          break
        end
        legion_domain_point_coloring_color_domain($srcColoring#12097, legion_domain_point_t(int3d({$x, $y, $z})), legion_domain_t(rect1d({$qBase, (($qBase+$Particles_maxXferNum)-1)})))
      end
    end
  end
  var $particles_qSrcPart_25 : partition(disjoint, $particles_queue_25, $primColors) = partition(disjoint, $particles_queue_25, $srcColoring#12097, $primColors)
  legion_domain_point_coloring_destroy($srcColoring#12097)
  var $dstColoring#12104 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  var $colorOff#12105 : int3d = int3d({-1, -1, -1})
  for $c : int3d($primColors) in $primColors do
    var $srcBase : int64
    for $qptr : int1d(int8[376], $13279) in $particles_qSrcPart_25[((($c-$colorOff#12105)+{$NX, $NY, $NZ})%{$NX, $NY, $NZ})] do
      $srcBase = int64(int1d($qptr))
      break
    end
    legion_domain_point_coloring_color_domain($dstColoring#12104, legion_domain_point_t($c), legion_domain_t(rect1d({$srcBase, (($srcBase+$Particles_maxXferNum)-1)})))
  end
  var $particles_qDstPart_25 : partition(aliased, $particles_queue_25, $primColors) = partition(aliased, $particles_queue_25, $dstColoring#12104, $primColors)
  legion_domain_point_coloring_destroy($dstColoring#12104)
  base.assert((($Radiation_xNum%$NX)==0), "Uneven partitioning")
  base.assert((($Radiation_yNum%$NY)==0), "Uneven partitioning")
  base.assert((($Radiation_zNum%$NZ)==0), "Uneven partitioning")
  var $coloring#12110 : legion_domain_point_coloring_t = legion_domain_point_coloring_create()
  for $c : int3d($primColors) in $primColors do
    var $rect : rect3d = rect3d({lo = int3d({x = ($Radiation_xBnum+(($Radiation_xNum/$NX)*$c.x)), y = ($Radiation_yBnum+(($Radiation_yNum/$NY)*$c.y)), z = ($Radiation_zBnum+(($Radiation_zNum/$NZ)*$c.z))}), hi = int3d({x = (($Radiation_xBnum+(($Radiation_xNum/$NX)*($c.x+1)))-1), y = (($Radiation_yBnum+(($Radiation_yNum/$NY)*($c.y+1)))-1), z = (($Radiation_zBnum+(($Radiation_zNum/$NZ)*($c.z+1)))-1)})})
    if ($c.x==0) then
      $rect.lo.x -= $Radiation_xBnum
    else
    end
    if ($c.x==($NX-1)) then
      $rect.hi.x += $Radiation_xBnum
    else
    end
    if ($c.y==0) then
      $rect.lo.y -= $Radiation_yBnum
    else
    end
    if ($c.y==($NY-1)) then
      $rect.hi.y += $Radiation_yBnum
    else
    end
    if ($c.z==0) then
      $rect.lo.z -= $Radiation_zBnum
    else
    end
    if ($c.z==($NZ-1)) then
      $rect.hi.z += $Radiation_zBnum
    else
    end
    legion_domain_point_coloring_color_domain($coloring#12110, legion_domain_point_t($c), legion_domain_t($rect))
  end
  var $Radiation_primPart : partition(disjoint, $Radiation, $primColors) = partition(disjoint, $Radiation, $coloring#12110, $primColors)
  var $Radiation_copy_primPart : partition(disjoint, $Radiation_copy, $primColors) = partition(disjoint, $Radiation_copy, $coloring#12110, $primColors)
  legion_domain_point_coloring_destroy($coloring#12110)
  __parallelize_with $Fluid_primPart, $particles_primPart, $Radiation_primPart, $primColors, (image($Fluid, $particles_primPart, $particles.cell)<=$Fluid_primPart) do
    particles_initValidField($particles)
    if ((not (($Grid_xNum%$Radiation_xNum)==int32(0))) or ((not (($Grid_yNum%$Radiation_yNum)==int32(0))) or (not (($Grid_zNum%$Radiation_zNum)==int32(0))))) then
      base.assert(false, "Inexact coarsening factor")
    else
    end
    SetCoarseningField($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum, $Radiation_xBnum, $Radiation_xNum, $Radiation_yBnum, $Radiation_yNum, $Radiation_zBnum, $Radiation_zNum)
    if (($config.BC.xBCLeft.__value==int32(0)) and ($config.BC.xBCRight.__value==int32(0))) then
      $BC_xSign = array($ONE, $ONE, $ONE)
      $BC_xPosVelocity = array($ZERO, $ZERO, $ZERO)
      $BC_xNegVelocity = array($ZERO, $ZERO, $ZERO)
      $BC_xPosTemperature = (-$ONE)
      $BC_xNegTemperature = (-$ONE)
      $BC_xBCLeftParticles = int32(0)
      $BC_xBCRightParticles = int32(0)
    else
      if (($config.BC.xBCLeft.__value==int32(1)) and ($config.BC.xBCRight.__value==int32(1))) then
        $BC_xSign = array((-$ONE), $ONE, $ONE)
        $BC_xPosVelocity = array($ZERO, $ZERO, $ZERO)
        $BC_xNegVelocity = array($ZERO, $ZERO, $ZERO)
        $BC_xPosTemperature = (-$ONE)
        $BC_xNegTemperature = (-$ONE)
        $BC_xBCLeftParticles = int32(1)
        $BC_xBCRightParticles = int32(1)
      else
        if (($config.BC.xBCLeft.__value==int32(2)) and ($config.BC.xBCRight.__value==int32(2))) then
          $BC_xSign = array((-$ONE), (-$ONE), (-$ONE))
          $BC_xPosVelocity = array((int32(2)*$config.BC.xBCRightVel[0]), (int32(2)*$config.BC.xBCRightVel[1]), (int32(2)*$config.BC.xBCRightVel[2]))
          $BC_xNegVelocity = array((int32(2)*$config.BC.xBCLeftVel[0]), (int32(2)*$config.BC.xBCLeftVel[1]), (int32(2)*$config.BC.xBCLeftVel[2]))
          $BC_xPosTemperature = (-$ONE)
          $BC_xNegTemperature = (-$ONE)
          $BC_xBCLeftParticles = int32(1)
          $BC_xBCRightParticles = int32(1)
        else
          if (($config.BC.xBCLeft.__value==int32(3)) and ($config.BC.xBCRight.__value==int32(3))) then
            $BC_xSign = array((-$ONE), (-$ONE), (-$ONE))
            $BC_xPosVelocity = array((int32(2)*$config.BC.xBCRightVel[0]), (int32(2)*$config.BC.xBCRightVel[1]), (int32(2)*$config.BC.xBCRightVel[2]))
            $BC_xNegVelocity = array((int32(2)*$config.BC.xBCLeftVel[0]), (int32(2)*$config.BC.xBCLeftVel[1]), (int32(2)*$config.BC.xBCLeftVel[2]))
            $BC_xPosTemperature = $config.BC.xBCRightTemp
            $BC_xNegTemperature = $config.BC.xBCLeftTemp
            $BC_xBCLeftParticles = int32(1)
            $BC_xBCRightParticles = int32(1)
          else
            base.assert(false, "Boundary conditions in x not implemented")
          end
        end
      end
    end
    if (($config.BC.yBCLeft.__value==int32(0)) and ($config.BC.yBCRight.__value==int32(0))) then
      $BC_ySign = array($ONE, $ONE, $ONE)
      $BC_yPosVelocity = array($ZERO, $ZERO, $ZERO)
      $BC_yNegVelocity = array($ZERO, $ZERO, $ZERO)
      $BC_yPosTemperature = (-$ONE)
      $BC_yNegTemperature = (-$ONE)
      $BC_yBCLeftParticles = int32(0)
      $BC_yBCRightParticles = int32(0)
    else
      if (($config.BC.yBCLeft.__value==int32(1)) and ($config.BC.yBCRight.__value==int32(1))) then
        $BC_ySign = array($ONE, (-$ONE), $ONE)
        $BC_yPosVelocity = array($ZERO, $ZERO, $ZERO)
        $BC_yNegVelocity = array($ZERO, $ZERO, $ZERO)
        $BC_yPosTemperature = (-$ONE)
        $BC_yNegTemperature = (-$ONE)
        $BC_yBCLeftParticles = int32(1)
        $BC_yBCRightParticles = int32(1)
      else
        if (($config.BC.yBCLeft.__value==int32(2)) and ($config.BC.yBCRight.__value==int32(2))) then
          $BC_ySign = array((-$ONE), (-$ONE), (-$ONE))
          $BC_yPosVelocity = array((int32(2)*$config.BC.yBCRightVel[0]), (int32(2)*$config.BC.yBCRightVel[1]), (int32(2)*$config.BC.yBCRightVel[2]))
          $BC_yNegVelocity = array((int32(2)*$config.BC.yBCLeftVel[0]), (int32(2)*$config.BC.yBCLeftVel[1]), (int32(2)*$config.BC.yBCLeftVel[2]))
          $BC_yPosTemperature = (-$ONE)
          $BC_yNegTemperature = (-$ONE)
          $BC_yBCLeftParticles = int32(1)
          $BC_yBCRightParticles = int32(1)
        else
          if (($config.BC.yBCLeft.__value==int32(3)) and ($config.BC.yBCRight.__value==int32(3))) then
            $BC_ySign = array((-$ONE), (-$ONE), (-$ONE))
            $BC_yPosVelocity = array((int32(2)*$config.BC.yBCRightVel[0]), (int32(2)*$config.BC.yBCRightVel[1]), (int32(2)*$config.BC.yBCRightVel[2]))
            $BC_yNegVelocity = array((int32(2)*$config.BC.yBCLeftVel[0]), (int32(2)*$config.BC.yBCLeftVel[1]), (int32(2)*$config.BC.yBCLeftVel[2]))
            $BC_yPosTemperature = $config.BC.yBCRightTemp
            $BC_yNegTemperature = $config.BC.yBCLeftTemp
            $BC_yBCLeftParticles = int32(1)
            $BC_yBCRightParticles = int32(1)
          else
            base.assert(false, "Boundary conditions in y not implemented")
          end
        end
      end
    end
    if (($config.BC.zBCLeft.__value==int32(0)) and ($config.BC.zBCRight.__value==int32(0))) then
      $BC_zSign = array($ONE, $ONE, $ONE)
      $BC_zPosVelocity = array($ZERO, $ZERO, $ZERO)
      $BC_zNegVelocity = array($ZERO, $ZERO, $ZERO)
      $BC_zPosTemperature = (-$ONE)
      $BC_zNegTemperature = (-$ONE)
      $BC_zBCLeftParticles = int32(0)
      $BC_zBCRightParticles = int32(0)
    else
      if (($config.BC.zBCLeft.__value==int32(1)) and ($config.BC.zBCRight.__value==int32(1))) then
        $BC_zSign = array($ONE, $ONE, (-$ONE))
        $BC_zPosVelocity = array($ZERO, $ZERO, $ZERO)
        $BC_zNegVelocity = array($ZERO, $ZERO, $ZERO)
        $BC_zPosTemperature = (-$ONE)
        $BC_zNegTemperature = (-$ONE)
        $BC_zBCLeftParticles = int32(1)
        $BC_zBCRightParticles = int32(1)
      else
        if (($config.BC.zBCLeft.__value==int32(2)) and ($config.BC.zBCRight.__value==int32(2))) then
          $BC_zSign = array((-$ONE), (-$ONE), (-$ONE))
          $BC_zPosVelocity = array((int32(2)*$config.BC.zBCRightVel[0]), (int32(2)*$config.BC.zBCRightVel[1]), (int32(2)*$config.BC.zBCRightVel[2]))
          $BC_zNegVelocity = array((int32(2)*$config.BC.zBCLeftVel[0]), (int32(2)*$config.BC.zBCLeftVel[1]), (int32(2)*$config.BC.zBCLeftVel[2]))
          $BC_zPosTemperature = (-$ONE)
          $BC_zNegTemperature = (-$ONE)
          $BC_zBCLeftParticles = int32(1)
          $BC_zBCRightParticles = int32(1)
        else
          if (($config.BC.zBCLeft.__value==int32(3)) and ($config.BC.zBCRight.__value==int32(3))) then
            $BC_zSign = array((-$ONE), (-$ONE), (-$ONE))
            $BC_zPosVelocity = array((int32(2)*$config.BC.zBCRightVel[0]), (int32(2)*$config.BC.zBCRightVel[1]), (int32(2)*$config.BC.zBCRightVel[2]))
            $BC_zNegVelocity = array((int32(2)*$config.BC.zBCLeftVel[0]), (int32(2)*$config.BC.zBCLeftVel[1]), (int32(2)*$config.BC.zBCLeftVel[2]))
            $BC_zPosTemperature = $config.BC.zBCRightTemp
            $BC_zNegTemperature = $config.BC.zBCLeftTemp
            $BC_zBCLeftParticles = int32(1)
            $BC_zBCRightParticles = int32(1)
          else
            base.assert(false, "Boundary conditions in z not implemented")
          end
        end
      end
    end
    if (not ((($config.BC.xBCLeft.__value==int32(0)) and ($config.BC.xBCRight.__value==int32(0))) or ((not ($config.BC.xBCLeft.__value==int32(0))) and (not ($config.BC.xBCRight.__value==int32(0)))))) then
      base.assert(false, "Boundary conditions in x should match for periodicity")
    else
    end
    if (not ((($config.BC.yBCLeft.__value==int32(0)) and ($config.BC.yBCRight.__value==int32(0))) or ((not ($config.BC.yBCLeft.__value==int32(0))) and (not ($config.BC.yBCRight.__value==int32(0)))))) then
      base.assert(false, "Boundary conditions in y should match for periodicity")
    else
    end
    if (not ((($config.BC.zBCLeft.__value==int32(0)) and ($config.BC.zBCRight.__value==int32(0))) or ((not ($config.BC.zBCLeft.__value==int32(0))) and (not ($config.BC.zBCRight.__value==int32(0)))))) then
      base.assert(false, "Boundary conditions in z should match for periodicity")
    else
    end
    if ($config.Flow.initCase.__value==int32(1)) then
      $Integrator_timeStep = $config.Integrator.restartIter
    else
    end
    Flow_InitializeCell($Fluid)
    Flow_InitializeCenterCoordinates($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_xOrigin, $Grid_xWidth, $Grid_yBnum, $Grid_yNum, $Grid_yOrigin, $Grid_yWidth, $Grid_zBnum, $Grid_zNum, $Grid_zOrigin, $Grid_zWidth)
    if ($config.Flow.initCase.__value==int32(0)) then
      Flow_InitializeUniform($Fluid, $Flow_initParams)
    else
    end
    if ($config.Flow.initCase.__value==int32(3)) then
      Flow_InitializeTaylorGreen2D($Fluid, $Flow_initParams, $Grid_xBnum, $Grid_xNum, $Grid_xOrigin, $Grid_xWidth, $Grid_yBnum, $Grid_yNum, $Grid_yOrigin, $Grid_yWidth, $Grid_zBnum, $Grid_zNum, $Grid_zOrigin, $Grid_zWidth)
    else
    end
    if ($config.Flow.initCase.__value==int32(4)) then
      Flow_InitializeTaylorGreen3D($Fluid, $Flow_initParams, $Grid_xBnum, $Grid_xNum, $Grid_xOrigin, $Grid_xWidth, $Grid_yBnum, $Grid_yNum, $Grid_yOrigin, $Grid_yWidth, $Grid_zBnum, $Grid_zNum, $Grid_zOrigin, $Grid_zWidth)
    else
    end
    if ($config.Flow.initCase.__value==int32(2)) then
      Flow_InitializePerturbed($Fluid, $Flow_initParams)
    else
    end
    if ($config.Flow.initCase.__value==int32(1)) then
      var $filename : &int8 = &int8(malloc(uint64(256)))
      snprintf($filename, uint64(256), "restart_fluid_%d.hdf", $config.Integrator.restartIter)
      Fluid_load_rho_pressure_velocity($primColors, concretize($filename), $Fluid, $Fluid_copy, $Fluid_primPart, $Fluid_copy_primPart)
      free(&opaque($filename))
    else
    end
    Flow_UpdateConservedFromPrimitive($Fluid, $Flow_gamma, $Flow_gasConstant, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateAuxiliaryVelocity($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostConservedStep1($Fluid, $BC_xNegTemperature, $BC_xNegVelocity, $BC_xPosTemperature, $BC_xPosVelocity, $BC_xSign, $BC_yNegTemperature, $BC_yNegVelocity, $BC_yPosTemperature, $BC_yPosVelocity, $BC_ySign, $BC_zNegTemperature, $BC_zNegVelocity, $BC_zPosTemperature, $BC_zPosVelocity, $BC_zSign, $Flow_gamma, $Flow_gasConstant, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostConservedStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostVelocityStep1($Fluid, $BC_xNegVelocity, $BC_xPosVelocity, $BC_xSign, $BC_yNegVelocity, $BC_yPosVelocity, $BC_ySign, $BC_zNegVelocity, $BC_zPosVelocity, $BC_zSign, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostVelocityStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_ComputeVelocityGradientAll($Fluid, $Grid_xBnum, $Grid_xCellWidth, $Grid_xNum, $Grid_yBnum, $Grid_yCellWidth, $Grid_yNum, $Grid_zBnum, $Grid_zCellWidth, $Grid_zNum)
    Flow_UpdateAuxiliaryThermodynamics($Fluid, $Flow_gamma, $Flow_gasConstant, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostThermodynamicsStep1($Fluid, $BC_xNegTemperature, $BC_xPosTemperature, $BC_yNegTemperature, $BC_yPosTemperature, $BC_zNegTemperature, $BC_zPosTemperature, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostThermodynamicsStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostFieldsStep1($Fluid, $BC_xNegTemperature, $BC_xNegVelocity, $BC_xPosTemperature, $BC_xPosVelocity, $BC_xSign, $BC_yNegTemperature, $BC_yNegVelocity, $BC_yPosTemperature, $BC_yPosVelocity, $BC_ySign, $BC_zNegTemperature, $BC_zNegVelocity, $BC_zPosTemperature, $BC_zPosVelocity, $BC_zSign, $Flow_gamma, $Flow_gasConstant, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    Flow_UpdateGhostFieldsStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    if ($config.Particles.initCase.__value==int32(0)) then
      base.assert(false, "Random particle initialization is disabled")
    else
    end
    if ($config.Particles.initCase.__value==int32(1)) then
      var $filename : &int8 = &int8(malloc(uint64(256)))
      snprintf($filename, uint64(256), "restart_particles_%d.hdf", $config.Integrator.restartIter)
      particles_load_cell_position_velocity_temperature_diameter___valid($primColors, concretize($filename), $particles, $particles_copy, $particles_primPart, $particles_copy_primPart)
      free(&opaque($filename))
      Particles_InitializeDensity($particles, $Particles_density)
      $Particles_number += Particles_CalculateNumber($particles)
    else
    end
    if ($config.Particles.initCase.__value==int32(2)) then
      InitParticlesUniform($particles, $Fluid, $config, $Grid_xBnum, $Grid_yBnum, $Grid_zBnum)
      $Particles_number = int64((($config.Particles.initNum/(($config.Grid.xTiles*$config.Grid.yTiles)*$config.Grid.zTiles))*(($config.Grid.xTiles*$config.Grid.yTiles)*$config.Grid.zTiles)))
    else
    end
    $Flow_averagePressure = double(int32(0))
    $Flow_averageTemperature = double(int32(0))
    $Flow_averageKineticEnergy = double(int32(0))
    $Flow_minTemperature = double(int32(inf))
    $Flow_maxTemperature = double(int32(-inf))
    $Flow_averagePD = double(int32(0))
    $Flow_averageDissipation = double(int32(0))
    $Particles_averageTemperature = double(int32(0))
    $Flow_averagePressure += CalculateAveragePressure($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_averageTemperature += CalculateAverageTemperature($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_averageKineticEnergy += CalculateAverageKineticEnergy($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_minTemperature min= CalculateMinTemperature($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_maxTemperature max= CalculateMaxTemperature($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Particles_averageTemperature += Particles_IntegrateQuantities($particles)
    $Flow_averagePressure = ($Flow_averagePressure/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
    $Flow_averageTemperature = ($Flow_averageTemperature/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
    $Flow_averageKineticEnergy = ($Flow_averageKineticEnergy/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
    $Particles_averageTemperature = ($Particles_averageTemperature/$Particles_number)
    var $ntx : int32 = $config.Grid.xTiles
    var $nty : int32 = $config.Grid.yTiles
    var $ntz : int32 = $config.Grid.zTiles
    var $grid_x : ispace(int3d) = ispace(int3d, int3d({x = ($Radiation_xNum+1), y = $Radiation_yNum, z = $Radiation_zNum}))
    var $grid_y : ispace(int3d) = ispace(int3d, int3d({x = $Radiation_xNum, y = ($Radiation_yNum+1), z = $Radiation_zNum}))
    var $grid_z : ispace(int3d) = ispace(int3d, int3d({x = $Radiation_xNum, y = $Radiation_yNum, z = ($Radiation_zNum+1)}))
    var $x_faces_1 : region(ispace(int3d), face) = region($grid_x, face)
    var $x_faces_2 : region(ispace(int3d), face) = region($grid_x, face)
    var $x_faces_3 : region(ispace(int3d), face) = region($grid_x, face)
    var $x_faces_4 : region(ispace(int3d), face) = region($grid_x, face)
    var $x_faces_5 : region(ispace(int3d), face) = region($grid_x, face)
    var $x_faces_6 : region(ispace(int3d), face) = region($grid_x, face)
    var $x_faces_7 : region(ispace(int3d), face) = region($grid_x, face)
    var $x_faces_8 : region(ispace(int3d), face) = region($grid_x, face)
    var $y_faces_1 : region(ispace(int3d), face) = region($grid_y, face)
    var $y_faces_2 : region(ispace(int3d), face) = region($grid_y, face)
    var $y_faces_3 : region(ispace(int3d), face) = region($grid_y, face)
    var $y_faces_4 : region(ispace(int3d), face) = region($grid_y, face)
    var $y_faces_5 : region(ispace(int3d), face) = region($grid_y, face)
    var $y_faces_6 : region(ispace(int3d), face) = region($grid_y, face)
    var $y_faces_7 : region(ispace(int3d), face) = region($grid_y, face)
    var $y_faces_8 : region(ispace(int3d), face) = region($grid_y, face)
    var $z_faces_1 : region(ispace(int3d), face) = region($grid_z, face)
    var $z_faces_2 : region(ispace(int3d), face) = region($grid_z, face)
    var $z_faces_3 : region(ispace(int3d), face) = region($grid_z, face)
    var $z_faces_4 : region(ispace(int3d), face) = region($grid_z, face)
    var $z_faces_5 : region(ispace(int3d), face) = region($grid_z, face)
    var $z_faces_6 : region(ispace(int3d), face) = region($grid_z, face)
    var $z_faces_7 : region(ispace(int3d), face) = region($grid_z, face)
    var $z_faces_8 : region(ispace(int3d), face) = region($grid_z, face)
    var $angle_indices : ispace(int1d) = ispace(int1d, int1d(14))
    var $angles : region(ispace(int1d), angle) = region($angle_indices, angle)
    var $x_tiles : ispace(int3d) = ispace(int3d, int3d({x = ($ntx+1), y = $nty, z = $ntz}))
    var $y_tiles : ispace(int3d) = ispace(int3d, int3d({x = $ntx, y = ($nty+1), z = $ntz}))
    var $z_tiles : ispace(int3d) = ispace(int3d, int3d({x = $ntx, y = $nty, z = ($ntz+1)}))
    var $p_x_faces_1 : partition(disjoint, $x_faces_1, $x_tiles) = make_interior_partition_x_lo($x_faces_1, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_1 : partition(disjoint, $y_faces_1, $y_tiles) = make_interior_partition_y_lo($y_faces_1, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_1 : partition(disjoint, $z_faces_1, $z_tiles) = make_interior_partition_z_lo($z_faces_1, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_x_faces_2 : partition(disjoint, $x_faces_2, $x_tiles) = make_interior_partition_x_lo($x_faces_2, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_2 : partition(disjoint, $y_faces_2, $y_tiles) = make_interior_partition_y_lo($y_faces_2, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_2 : partition(disjoint, $z_faces_2, $z_tiles) = make_interior_partition_z_hi($z_faces_2, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_x_faces_3 : partition(disjoint, $x_faces_3, $x_tiles) = make_interior_partition_x_lo($x_faces_3, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_3 : partition(disjoint, $y_faces_3, $y_tiles) = make_interior_partition_y_hi($y_faces_3, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_3 : partition(disjoint, $z_faces_3, $z_tiles) = make_interior_partition_z_lo($z_faces_3, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_x_faces_4 : partition(disjoint, $x_faces_4, $x_tiles) = make_interior_partition_x_lo($x_faces_4, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_4 : partition(disjoint, $y_faces_4, $y_tiles) = make_interior_partition_y_hi($y_faces_4, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_4 : partition(disjoint, $z_faces_4, $z_tiles) = make_interior_partition_z_hi($z_faces_4, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_x_faces_5 : partition(disjoint, $x_faces_5, $x_tiles) = make_interior_partition_x_hi($x_faces_5, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_5 : partition(disjoint, $y_faces_5, $y_tiles) = make_interior_partition_y_lo($y_faces_5, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_5 : partition(disjoint, $z_faces_5, $z_tiles) = make_interior_partition_z_lo($z_faces_5, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_x_faces_6 : partition(disjoint, $x_faces_6, $x_tiles) = make_interior_partition_x_hi($x_faces_6, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_6 : partition(disjoint, $y_faces_6, $y_tiles) = make_interior_partition_y_lo($y_faces_6, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_6 : partition(disjoint, $z_faces_6, $z_tiles) = make_interior_partition_z_hi($z_faces_6, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_x_faces_7 : partition(disjoint, $x_faces_7, $x_tiles) = make_interior_partition_x_hi($x_faces_7, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_7 : partition(disjoint, $y_faces_7, $y_tiles) = make_interior_partition_y_hi($y_faces_7, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_7 : partition(disjoint, $z_faces_7, $z_tiles) = make_interior_partition_z_lo($z_faces_7, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_x_faces_8 : partition(disjoint, $x_faces_8, $x_tiles) = make_interior_partition_x_hi($x_faces_8, $x_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_y_faces_8 : partition(disjoint, $y_faces_8, $y_tiles) = make_interior_partition_y_hi($y_faces_8, $y_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    var $p_z_faces_8 : partition(disjoint, $z_faces_8, $z_tiles) = make_interior_partition_z_hi($z_faces_8, $z_tiles, $Radiation_xNum, $Radiation_yNum, $Radiation_zNum, $ntx, $nty, $ntz)
    if ($config.Radiation.type.__value==int32(2)) then
      Radiation_InitializeCell($Radiation)
      initialize_faces($x_faces_1)
      initialize_faces($x_faces_2)
      initialize_faces($x_faces_3)
      initialize_faces($x_faces_4)
      initialize_faces($x_faces_5)
      initialize_faces($x_faces_6)
      initialize_faces($x_faces_7)
      initialize_faces($x_faces_8)
      initialize_faces($y_faces_1)
      initialize_faces($y_faces_2)
      initialize_faces($y_faces_3)
      initialize_faces($y_faces_4)
      initialize_faces($y_faces_5)
      initialize_faces($y_faces_6)
      initialize_faces($y_faces_7)
      initialize_faces($y_faces_8)
      initialize_faces($z_faces_1)
      initialize_faces($z_faces_2)
      initialize_faces($z_faces_3)
      initialize_faces($z_faces_4)
      initialize_faces($z_faces_5)
      initialize_faces($z_faces_6)
      initialize_faces($z_faces_7)
      initialize_faces($z_faces_8)
      initialize_angles($angles)
    else
    end
    if (($Integrator_timeStep%$config.IO.consoleFrequency)==int32(0)) then
      if (($Integrator_timeStep%$config.IO.headerFrequency)==int32(0)) then
        printf("\n Current time step: %2.6e s.\n", $Integrator_deltaTime)
        printf(" Min Flow Temp: %11.6f K. Max Flow Temp: %11.6f K.\n", $Flow_minTemperature, $Flow_maxTemperature)
        printf(" Current number of particles: %d.\n", $Particles_number)
        printf("\n")
        printf("    Iter     Time(s)   Avg Press    Avg Temp      Avg KE  Particle T\n")
      else
      end
      printf("%8d %11.6f %11.6f %11.6f %11.6f %11.6f\n", $Integrator_timeStep, $Integrator_simTime, $Flow_averagePressure, $Flow_averageTemperature, $Flow_averageKineticEnergy, $Particles_averageTemperature)
    else
    end
    if ($config.IO.wrtRestart.__value==int32(1)) then
      if (($Integrator_timeStep%$config.IO.restartEveryTimeSteps)==int32(0)) then
        var $filename : &int8 = &int8(malloc(uint64(256)))
        snprintf($filename, uint64(256), "restart_fluid_%d.hdf", $Integrator_timeStep)
        Fluid_dump_rho_pressure_velocity($primColors, concretize($filename), $Fluid, $Fluid_copy, $Fluid_primPart, $Fluid_copy_primPart)
        free(&opaque($filename))
      else
      end
      if (($Integrator_timeStep%$config.IO.restartEveryTimeSteps)==int32(0)) then
        var $filename : &int8 = &int8(malloc(uint64(256)))
        snprintf($filename, uint64(256), "restart_particles_%d.hdf", $Integrator_timeStep)
        particles_dump_cell_position_velocity_temperature_diameter___valid($primColors, concretize($filename), $particles, $particles_copy, $particles_primPart, $particles_copy_primPart)
        free(&opaque($filename))
      else
      end
    else
    end
    while (($Integrator_simTime<$config.Integrator.finalTime) and ($Integrator_timeStep<$config.Integrator.maxIter)) do
      if ($config.Integrator.cfl<int32(0)) then
        $Integrator_deltaTime = $config.Integrator.fixedDeltaTime
      else
        $Integrator_maxConvectiveSpectralRadius max= CalculateConvectiveSpectralRadius($Fluid, $Flow_gamma, $Flow_gasConstant, $Grid_dXYZInverseSquare, $Grid_xCellWidth, $Grid_yCellWidth, $Grid_zCellWidth)
        $Integrator_maxViscousSpectralRadius max= CalculateViscousSpectralRadius($Fluid, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value, $Grid_dXYZInverseSquare)
        $Integrator_maxHeatConductionSpectralRadius max= CalculateHeatConductionSpectralRadius($Fluid, $Flow_constantVisc, $Flow_gamma, $Flow_gasConstant, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_prandtl, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value, $Grid_dXYZInverseSquare)
        $Integrator_deltaTime = ($config.Integrator.cfl/max($Integrator_maxConvectiveSpectralRadius, max($Integrator_maxViscousSpectralRadius, $Integrator_maxHeatConductionSpectralRadius)))
      end
      Flow_InitializeTemporaries($Fluid)
      Particles_InitializeTemporaries($particles)
      $Integrator_time_old = $Integrator_simTime
      $Integrator_stage = int32(1)
      while ($Integrator_stage<int32(5)) do
        Flow_InitializeTimeDerivatives($Fluid)
        Particles_InitializeTimeDerivatives($particles)
        Flow_UpdateGhostVelocityGradientStep1($Fluid, $BC_xSign, $BC_ySign, $BC_zSign, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_UpdateGhostVelocityGradientStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_AddGetFlux($Fluid, $Flow_constantVisc, $Flow_gamma, $Flow_gasConstant, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_prandtl, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value, $Grid_xBnum, $Grid_xCellWidth, $Grid_xNum, $Grid_yBnum, $Grid_yCellWidth, $Grid_yNum, $Grid_zBnum, $Grid_zCellWidth, $Grid_zNum)
        Flow_AddUpdateUsingFlux($Fluid, $Grid_xBnum, $Grid_xCellWidth, $Grid_xNum, $Grid_yBnum, $Grid_yCellWidth, $Grid_yNum, $Grid_zBnum, $Grid_zCellWidth, $Grid_zNum)
        Flow_AddBodyForces($Fluid, $Flow_bodyForce, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        if ($config.Flow.turbForcing.__value==int32(1)) then
          $Flow_averagePD = double(int32(0))
          $Flow_averageDissipation = double(int32(0))
          $Flow_averageFe = double(int32(0))
          $Flow_averageK = double(int32(0))
          Flow_UpdatePD($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          Flow_ResetDissipation($Fluid)
          Flow_ComputeDissipationX($Fluid, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value, $Grid_xBnum, $Grid_xCellWidth, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          Flow_UpdateDissipationX($Fluid, $Grid_xBnum, $Grid_xCellWidth, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          Flow_ComputeDissipationY($Fluid, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yCellWidth, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          Flow_UpdateDissipationY($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yCellWidth, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          Flow_ComputeDissipationZ($Fluid, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zCellWidth, $Grid_zNum)
          Flow_UpdateDissipationZ($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zCellWidth, $Grid_zNum)
          $Flow_averagePD += CalculateAveragePD($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          $Flow_averagePD = ($Flow_averagePD/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
          $Flow_averageDissipation += CalculateAverageDissipation($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          $Flow_averageDissipation = ($Flow_averageDissipation/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
          $Flow_averageK += CalculateAverageK($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          $Flow_averageK = ($Flow_averageK/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
          $Flow_averageFe += Flow_AddTurbulentSource($Fluid, $Flow_averageDissipation, $Flow_averageK, $Flow_averagePD, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
          $Flow_averageFe = ($Flow_averageFe/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
          Flow_AdjustTurbulentSource($Fluid, $Flow_averageFe, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        else
        end
        for $c : int3d($primColors) in $primColors do
          Particles_LocateInCells($particles_primPart[int3d($c)], $BC_xBCPeriodic, $BC_yBCPeriodic, $BC_zBCPeriodic, $Grid_xBnum, $Grid_xNum, $Grid_xOrigin, $Grid_xWidth, $Grid_yBnum, $Grid_yNum, $Grid_yOrigin, $Grid_yWidth, $Grid_zBnum, $Grid_zNum, $Grid_zOrigin, $Grid_zWidth)
        end
        for $c : int3d($primColors) in $primColors do
          particles_pushAll(int3d($c), $particles_primPart[int3d($c)], $particles_qSrcPart_0[int3d($c)], $particles_qSrcPart_1[int3d($c)], $particles_qSrcPart_2[int3d($c)], $particles_qSrcPart_3[int3d($c)], $particles_qSrcPart_4[int3d($c)], $particles_qSrcPart_5[int3d($c)], $particles_qSrcPart_6[int3d($c)], $particles_qSrcPart_7[int3d($c)], $particles_qSrcPart_8[int3d($c)], $particles_qSrcPart_9[int3d($c)], $particles_qSrcPart_10[int3d($c)], $particles_qSrcPart_11[int3d($c)], $particles_qSrcPart_12[int3d($c)], $particles_qSrcPart_13[int3d($c)], $particles_qSrcPart_14[int3d($c)], $particles_qSrcPart_15[int3d($c)], $particles_qSrcPart_16[int3d($c)], $particles_qSrcPart_17[int3d($c)], $particles_qSrcPart_18[int3d($c)], $particles_qSrcPart_19[int3d($c)], $particles_qSrcPart_20[int3d($c)], $particles_qSrcPart_21[int3d($c)], $particles_qSrcPart_22[int3d($c)], $particles_qSrcPart_23[int3d($c)], $particles_qSrcPart_24[int3d($c)], $particles_qSrcPart_25[int3d($c)], $Grid_xNum, $Grid_yNum, $Grid_zNum, $Grid_xBnum, $Grid_yBnum, $Grid_zBnum, $NX, $NY, $NZ)
        end
        for $c : int3d($primColors) in $primColors do
          particles_pullAll(int3d($c), $particles_primPart[int3d($c)], $particles_qDstPart_0[int3d($c)], $particles_qDstPart_1[int3d($c)], $particles_qDstPart_2[int3d($c)], $particles_qDstPart_3[int3d($c)], $particles_qDstPart_4[int3d($c)], $particles_qDstPart_5[int3d($c)], $particles_qDstPart_6[int3d($c)], $particles_qDstPart_7[int3d($c)], $particles_qDstPart_8[int3d($c)], $particles_qDstPart_9[int3d($c)], $particles_qDstPart_10[int3d($c)], $particles_qDstPart_11[int3d($c)], $particles_qDstPart_12[int3d($c)], $particles_qDstPart_13[int3d($c)], $particles_qDstPart_14[int3d($c)], $particles_qDstPart_15[int3d($c)], $particles_qDstPart_16[int3d($c)], $particles_qDstPart_17[int3d($c)], $particles_qDstPart_18[int3d($c)], $particles_qDstPart_19[int3d($c)], $particles_qDstPart_20[int3d($c)], $particles_qDstPart_21[int3d($c)], $particles_qDstPart_22[int3d($c)], $particles_qDstPart_23[int3d($c)], $particles_qDstPart_24[int3d($c)], $particles_qDstPart_25[int3d($c)])
        end
        Particles_AddFlowCoupling($particles, $Fluid, $Flow_constantVisc, $Flow_powerlawTempRef, $Flow_powerlawViscRef, $Flow_sutherlandSRef, $Flow_sutherlandTempRef, $Flow_sutherlandViscRef, $Flow_viscosityModel___value, $Grid_xCellWidth, $Grid_xRealOrigin, $Grid_yCellWidth, $Grid_yRealOrigin, $Grid_zCellWidth, $Grid_zRealOrigin, $Particles_convectiveCoeff, $Particles_heatCapacity)
        Particles_AddBodyForces($particles, $Particles_bodyForce)
        if ($config.Radiation.type.__value==int32(1)) then
          AddRadiation($particles, $config)
        else
        end
        if ($config.Radiation.type.__value==int32(2)) then
          Radiation_ClearAccumulators($Radiation)
          for $c : int3d($primColors) in $primColors do
            Radiation_AccumulateParticleValues($particles_primPart[int3d($c)], $Fluid_primPart[int3d($c)], $Radiation_primPart[int3d($c)])
          end
          Radiation_UpdateFieldValues($Radiation, $Radiation_cellVolume, $Radiation_qa, $Radiation_qs)
          var $t : int64 = int64(1)
          var $omega : double = ($config.Radiation.qs/($config.Radiation.qa+$config.Radiation.qs))
          var $res : double = 1
          while ($res>1e-06) do
            for $color : int3d($primColors) in $primColors do
              source_term($Radiation_primPart[int3d($color)], $angles, $omega)
            end
            for $j : int32 = 0, $nty do
              for $k : int32 = 0, $ntz do
                west_bound($p_x_faces_1[int3d({1, $j, $k})], $p_x_faces_2[int3d({1, $j, $k})], $p_x_faces_3[int3d({1, $j, $k})], $p_x_faces_4[int3d({1, $j, $k})], $p_x_faces_5[int3d({0, $j, $k})], $p_x_faces_6[int3d({0, $j, $k})], $p_x_faces_7[int3d({0, $j, $k})], $p_x_faces_8[int3d({0, $j, $k})], $angles, $config.Radiation.emissWest, $config.Radiation.tempWest)
                east_bound($p_x_faces_1[int3d({$ntx, $j, $k})], $p_x_faces_2[int3d({$ntx, $j, $k})], $p_x_faces_3[int3d({$ntx, $j, $k})], $p_x_faces_4[int3d({$ntx, $j, $k})], $p_x_faces_5[int3d({($ntx-1), $j, $k})], $p_x_faces_6[int3d({($ntx-1), $j, $k})], $p_x_faces_7[int3d({($ntx-1), $j, $k})], $p_x_faces_8[int3d({($ntx-1), $j, $k})], $angles, $config.Radiation.emissEast, $config.Radiation.tempEast)
              end
            end
            for $i : int32 = 0, $ntx do
              for $k : int32 = 0, $ntz do
                south_bound($p_y_faces_1[int3d({$i, 1, $k})], $p_y_faces_2[int3d({$i, 1, $k})], $p_y_faces_3[int3d({$i, 0, $k})], $p_y_faces_4[int3d({$i, 0, $k})], $p_y_faces_5[int3d({$i, 1, $k})], $p_y_faces_6[int3d({$i, 1, $k})], $p_y_faces_7[int3d({$i, 0, $k})], $p_y_faces_8[int3d({$i, 0, $k})], $angles, $config.Radiation.emissSouth, $config.Radiation.tempSouth)
                north_bound($p_y_faces_1[int3d({$i, $nty, $k})], $p_y_faces_2[int3d({$i, $nty, $k})], $p_y_faces_3[int3d({$i, ($nty-1), $k})], $p_y_faces_4[int3d({$i, ($nty-1), $k})], $p_y_faces_5[int3d({$i, $nty, $k})], $p_y_faces_6[int3d({$i, $nty, $k})], $p_y_faces_7[int3d({$i, ($nty-1), $k})], $p_y_faces_8[int3d({$i, ($nty-1), $k})], $angles, $config.Radiation.emissNorth, $config.Radiation.tempNorth)
              end
            end
            for $i : int32 = 0, $ntx do
              for $j : int32 = 0, $nty do
                up_bound($p_z_faces_1[int3d({$i, $j, 1})], $p_z_faces_2[int3d({$i, $j, 0})], $p_z_faces_3[int3d({$i, $j, 1})], $p_z_faces_4[int3d({$i, $j, 0})], $p_z_faces_5[int3d({$i, $j, 1})], $p_z_faces_6[int3d({$i, $j, 0})], $p_z_faces_7[int3d({$i, $j, 1})], $p_z_faces_8[int3d({$i, $j, 0})], $angles, $config.Radiation.emissUp, $config.Radiation.tempUp)
                down_bound($p_z_faces_1[int3d({$i, $j, $ntz})], $p_z_faces_2[int3d({$i, $j, ($ntz-1)})], $p_z_faces_3[int3d({$i, $j, $ntz})], $p_z_faces_4[int3d({$i, $j, ($ntz-1)})], $p_z_faces_5[int3d({$i, $j, $ntz})], $p_z_faces_6[int3d({$i, $j, ($ntz-1)})], $p_z_faces_7[int3d({$i, $j, $ntz})], $p_z_faces_8[int3d({$i, $j, ($ntz-1)})], $angles, $config.Radiation.emissDown, $config.Radiation.tempDown)
              end
            end
            for $i : int32 = 0, $ntx do
              for $j : int32 = 0, $nty do
                for $k : int32 = 0, $ntz do
                  sweep_1($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_1[int3d({($i+1), $j, $k})], $p_y_faces_1[int3d({$i, ($j+1), $k})], $p_z_faces_1[int3d({$i, $j, ($k+1)})], $p_x_faces_1[int3d({$i, $j, $k})], $p_y_faces_1[int3d({$i, $j, $k})], $p_z_faces_1[int3d({$i, $j, $k})], $angles, int64(1), int64(1), int64(1), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            for $i : int32 = 0, $ntx do
              for $j : int32 = 0, $nty do
                for $k : int32 = ($ntz-1), (-1), (-1) do
                  sweep_2($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_2[int3d({($i+1), $j, $k})], $p_y_faces_2[int3d({$i, ($j+1), $k})], $p_z_faces_2[int3d({$i, $j, $k})], $p_x_faces_2[int3d({$i, $j, $k})], $p_y_faces_2[int3d({$i, $j, $k})], $p_z_faces_2[int3d({$i, $j, ($k+1)})], $angles, int64(1), int64(1), int64((-1)), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            for $i : int32 = 0, $ntx do
              for $j : int32 = ($nty-1), (-1), (-1) do
                for $k : int32 = 0, $ntz do
                  sweep_3($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_3[int3d({($i+1), $j, $k})], $p_y_faces_3[int3d({$i, $j, $k})], $p_z_faces_3[int3d({$i, $j, ($k+1)})], $p_x_faces_3[int3d({$i, $j, $k})], $p_y_faces_3[int3d({$i, ($j+1), $k})], $p_z_faces_3[int3d({$i, $j, $k})], $angles, int64(1), int64((-1)), int64(1), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            for $i : int32 = 0, $ntx do
              for $j : int32 = ($nty-1), (-1), (-1) do
                for $k : int32 = ($ntz-1), (-1), (-1) do
                  sweep_4($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_4[int3d({($i+1), $j, $k})], $p_y_faces_4[int3d({$i, $j, $k})], $p_z_faces_4[int3d({$i, $j, $k})], $p_x_faces_4[int3d({$i, $j, $k})], $p_y_faces_4[int3d({$i, ($j+1), $k})], $p_z_faces_4[int3d({$i, $j, ($k+1)})], $angles, int64(1), int64((-1)), int64((-1)), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            for $i : int32 = ($ntx-1), (-1), (-1) do
              for $j : int32 = 0, $nty do
                for $k : int32 = 0, $ntz do
                  sweep_5($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_5[int3d({$i, $j, $k})], $p_y_faces_5[int3d({$i, ($j+1), $k})], $p_z_faces_5[int3d({$i, $j, ($k+1)})], $p_x_faces_5[int3d({($i+1), $j, $k})], $p_y_faces_5[int3d({$i, $j, $k})], $p_z_faces_5[int3d({$i, $j, $k})], $angles, int64((-1)), int64(1), int64(1), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            for $i : int32 = ($ntx-1), (-1), (-1) do
              for $j : int32 = 0, $nty do
                for $k : int32 = ($ntz-1), (-1), (-1) do
                  sweep_6($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_6[int3d({$i, $j, $k})], $p_y_faces_6[int3d({$i, ($j+1), $k})], $p_z_faces_6[int3d({$i, $j, $k})], $p_x_faces_6[int3d({($i+1), $j, $k})], $p_y_faces_6[int3d({$i, $j, $k})], $p_z_faces_6[int3d({$i, $j, ($k+1)})], $angles, int64((-1)), int64(1), int64((-1)), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            for $i : int32 = ($ntx-1), (-1), (-1) do
              for $j : int32 = ($nty-1), (-1), (-1) do
                for $k : int32 = 0, $ntz do
                  sweep_7($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_7[int3d({$i, $j, $k})], $p_y_faces_7[int3d({$i, $j, $k})], $p_z_faces_7[int3d({$i, $j, ($k+1)})], $p_x_faces_7[int3d({($i+1), $j, $k})], $p_y_faces_7[int3d({$i, ($j+1), $k})], $p_z_faces_7[int3d({$i, $j, $k})], $angles, int64((-1)), int64((-1)), int64(1), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            for $i : int32 = ($ntx-1), (-1), (-1) do
              for $j : int32 = ($nty-1), (-1), (-1) do
                for $k : int32 = ($ntz-1), (-1), (-1) do
                  sweep_8($Radiation_primPart[int3d({$i, $j, $k})], $p_x_faces_8[int3d({$i, $j, $k})], $p_y_faces_8[int3d({$i, $j, $k})], $p_z_faces_8[int3d({$i, $j, $k})], $p_x_faces_8[int3d({($i+1), $j, $k})], $p_y_faces_8[int3d({$i, ($j+1), $k})], $p_z_faces_8[int3d({$i, $j, ($k+1)})], $angles, int64((-1)), int64((-1)), int64((-1)), $Radiation_xCellWidth, $Radiation_yCellWidth, $Radiation_zCellWidth)
                end
              end
            end
            $res = 0
            for $color : int3d($primColors) in $primColors do
              $res += residual($Radiation_primPart[int3d($color)], $Radiation_xNum, $Radiation_yNum, $Radiation_zNum)
            end
            $res = sqrt($res)
            for $color : int3d($primColors) in $primColors do
              update($Radiation_primPart[int3d($color)])
            end
            if ($t==1) then
              printf("\n")
              printf(" Iteration     Residual         \n")
              printf(" ------------------------------ \n")
            else
            end
            printf("   %3d    %.15e \n", $t, $res)
            $t = ($t+1)
          end
          for $color : int3d($primColors) in $primColors do
            reduce_intensity($Radiation_primPart[int3d($color)], $angles)
          end
          for $c : int3d($primColors) in $primColors do
            Particles_AbsorbRadiation($particles_primPart[int3d($c)], $Fluid_primPart[int3d($c)], $Radiation_primPart[int3d($c)], $Particles_heatCapacity, $Radiation_qa)
          end
        else
        end
        Flow_AddParticlesCoupling($particles, $Fluid, $Grid_cellVolume)
        Flow_UpdateVars($Fluid, $Integrator_deltaTime, $Integrator_stage)
        Particles_UpdateVars($particles, $Integrator_deltaTime, $Integrator_stage)
        Flow_UpdateAuxiliaryVelocity($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_UpdateGhostConservedStep1($Fluid, $BC_xNegTemperature, $BC_xNegVelocity, $BC_xPosTemperature, $BC_xPosVelocity, $BC_xSign, $BC_yNegTemperature, $BC_yNegVelocity, $BC_yPosTemperature, $BC_yPosVelocity, $BC_ySign, $BC_zNegTemperature, $BC_zNegVelocity, $BC_zPosTemperature, $BC_zPosVelocity, $BC_zSign, $Flow_gamma, $Flow_gasConstant, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_UpdateGhostConservedStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_UpdateGhostVelocityStep1($Fluid, $BC_xNegVelocity, $BC_xPosVelocity, $BC_xSign, $BC_yNegVelocity, $BC_yPosVelocity, $BC_ySign, $BC_zNegVelocity, $BC_zPosVelocity, $BC_zSign, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_UpdateGhostVelocityStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_ComputeVelocityGradientAll($Fluid, $Grid_xBnum, $Grid_xCellWidth, $Grid_xNum, $Grid_yBnum, $Grid_yCellWidth, $Grid_yNum, $Grid_zBnum, $Grid_zCellWidth, $Grid_zNum)
        Flow_UpdateAuxiliaryThermodynamics($Fluid, $Flow_gamma, $Flow_gasConstant, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_UpdateGhostThermodynamicsStep1($Fluid, $BC_xNegTemperature, $BC_xPosTemperature, $BC_yNegTemperature, $BC_yPosTemperature, $BC_zNegTemperature, $BC_zPosTemperature, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Flow_UpdateGhostThermodynamicsStep2($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        Particles_UpdateAuxiliaryStep1($particles, $BC_xBCLeftParticles, $BC_xBCRightParticles, $BC_yBCLeftParticles, $BC_yBCRightParticles, $BC_zBCLeftParticles, $BC_zBCRightParticles, $Grid_xOrigin, $Grid_xWidth, $Grid_yOrigin, $Grid_yWidth, $Grid_zOrigin, $Grid_zWidth, $Particles_restitutionCoeff)
        Particles_UpdateAuxiliaryStep2($particles)
        $Integrator_simTime = ($Integrator_time_old+((double(0.5)*(int32(1)+($Integrator_stage/int32(3))))*$Integrator_deltaTime))
        $Integrator_stage = ($Integrator_stage+int32(1))
        for $c : int3d($primColors) in $primColors do
          $Particles_number += Particles_DeleteEscapingParticles($particles_primPart[int3d($c)], $Grid_xRealOrigin, $Grid_xRealWidth, $Grid_yRealOrigin, $Grid_yRealWidth, $Grid_zRealOrigin, $Grid_zRealWidth)
        end
      end
      $Integrator_timeStep = ($Integrator_timeStep+int32(1))
      if (($Integrator_timeStep%$config.IO.consoleFrequency)==int32(0)) then
        $Flow_averagePressure = double(int32(0))
        $Flow_averageTemperature = double(int32(0))
        $Flow_averageKineticEnergy = double(int32(0))
        $Flow_minTemperature = double(int32(inf))
        $Flow_maxTemperature = double(int32(-inf))
        $Flow_averagePD = double(int32(0))
        $Flow_averageDissipation = double(int32(0))
        $Particles_averageTemperature = double(int32(0))
        $Flow_averagePressure += CalculateAveragePressure($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        $Flow_averageTemperature += CalculateAverageTemperature($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        $Flow_averageKineticEnergy += CalculateAverageKineticEnergy($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        $Flow_minTemperature min= CalculateMinTemperature($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        $Flow_maxTemperature max= CalculateMaxTemperature($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
        $Particles_averageTemperature += Particles_IntegrateQuantities($particles)
        $Flow_averagePressure = ($Flow_averagePressure/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
        $Flow_averageTemperature = ($Flow_averageTemperature/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
        $Flow_averageKineticEnergy = ($Flow_averageKineticEnergy/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
        $Particles_averageTemperature = ($Particles_averageTemperature/$Particles_number)
        if (($Integrator_timeStep%$config.IO.consoleFrequency)==int32(0)) then
          if (($Integrator_timeStep%$config.IO.headerFrequency)==int32(0)) then
            printf("\n Current time step: %2.6e s.\n", $Integrator_deltaTime)
            printf(" Min Flow Temp: %11.6f K. Max Flow Temp: %11.6f K.\n", $Flow_minTemperature, $Flow_maxTemperature)
            printf(" Current number of particles: %d.\n", $Particles_number)
            printf("\n")
            printf("    Iter     Time(s)   Avg Press    Avg Temp      Avg KE  Particle T\n")
          else
          end
          printf("%8d %11.6f %11.6f %11.6f %11.6f %11.6f\n", $Integrator_timeStep, $Integrator_simTime, $Flow_averagePressure, $Flow_averageTemperature, $Flow_averageKineticEnergy, $Particles_averageTemperature)
        else
        end
        if ($config.IO.wrtRestart.__value==int32(1)) then
          if (($Integrator_timeStep%$config.IO.restartEveryTimeSteps)==int32(0)) then
            var $filename : &int8 = &int8(malloc(uint64(256)))
            snprintf($filename, uint64(256), "restart_fluid_%d.hdf", $Integrator_timeStep)
            Fluid_dump_rho_pressure_velocity_($primColors, concretize($filename), $Fluid, $Fluid_copy, $Fluid_primPart, $Fluid_copy_primPart)
            free(&opaque($filename))
          else
          end
          if (($Integrator_timeStep%$config.IO.restartEveryTimeSteps)==int32(0)) then
            var $filename : &int8 = &int8(malloc(uint64(256)))
            snprintf($filename, uint64(256), "restart_particles_%d.hdf", $Integrator_timeStep)
            particles_dump_cell_position_velocity_temperature_diameter___valid_($primColors, concretize($filename), $particles, $particles_copy, $particles_primPart, $particles_copy_primPart)
            free(&opaque($filename))
          else
          end
        else
        end
      else
      end
    end
    $Flow_averagePressure = double(int32(0))
    $Flow_averageTemperature = double(int32(0))
    $Flow_averageKineticEnergy = double(int32(0))
    $Flow_minTemperature = double(int32(inf))
    $Flow_maxTemperature = double(int32(-inf))
    $Flow_averagePD = double(int32(0))
    $Flow_averageDissipation = double(int32(0))
    $Particles_averageTemperature = double(int32(0))
    $Flow_averagePressure += CalculateAveragePressure($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_averageTemperature += CalculateAverageTemperature($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_averageKineticEnergy += CalculateAverageKineticEnergy($Fluid, $Grid_cellVolume, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_minTemperature min= CalculateMinTemperature($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Flow_maxTemperature max= CalculateMaxTemperature($Fluid, $Grid_xBnum, $Grid_xNum, $Grid_yBnum, $Grid_yNum, $Grid_zBnum, $Grid_zNum)
    $Particles_averageTemperature += Particles_IntegrateQuantities($particles)
    $Flow_averagePressure = ($Flow_averagePressure/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
    $Flow_averageTemperature = ($Flow_averageTemperature/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
    $Flow_averageKineticEnergy = ($Flow_averageKineticEnergy/((($Grid_xNum*$Grid_yNum)*$Grid_zNum)*$Grid_cellVolume))
    $Particles_averageTemperature = ($Particles_averageTemperature/$Particles_number)
    if (($Integrator_timeStep%$config.IO.consoleFrequency)==int32(0)) then
      if (($Integrator_timeStep%$config.IO.headerFrequency)==int32(0)) then
        printf("\n Current time step: %2.6e s.\n", $Integrator_deltaTime)
        printf(" Min Flow Temp: %11.6f K. Max Flow Temp: %11.6f K.\n", $Flow_minTemperature, $Flow_maxTemperature)
        printf(" Current number of particles: %d.\n", $Particles_number)
        printf("\n")
        printf("    Iter     Time(s)   Avg Press    Avg Temp      Avg KE  Particle T\n")
      else
      end
      printf("%8d %11.6f %11.6f %11.6f %11.6f %11.6f\n", $Integrator_timeStep, $Integrator_simTime, $Flow_averagePressure, $Flow_averageTemperature, $Flow_averageKineticEnergy, $Particles_averageTemperature)
    else
    end
  end
end

task main()
-- leaf (false), inner (false), idempotent (false)
  var $args : legion_input_args_t = legion_runtime_get_input_args()
  for $i : int32 = 1, $args.argc do
    if ((strcmp($args.argv[$i], "-i")==0) and ($i<($args.argc-1))) then
      work(parseConfig($args.argv[($i+1)]))
    else
    end
  end
end

